# The AOI Roadmap

This roadmap is a **recommended learning path** for AOI students who want to gradually build their competitive programming and problem-solving skills.  

⚠️ **Important:**  

- Focus on **problem-solving skills** more than rushing to advance in the roadmap.  
- Make sure your **basics are strong** before moving on.  
- You are not obliged to complete the whole roadmap — it is just a **suggestion of what to do next**.  
- **Practice a lot** — solving problems consistently is the most effective way to improve.  
- Learn to **write clean solutions and explain your reasoning** — clarity is as important as correctness.  
- Always review your mistakes and **analyze why a solution failed** — this is where the real learning happens.  

---

## Phase 1 – Foundations

- [Language basics (C++): I/O, loops, conditionals, functions](fundamentals/intro-to-c%2B%2B.md)  
- [Complexity analysis (Big-O, simple cases)](fundamentals/time-complexity.md)
- Basic math: [logic](math/proof-writing.md), [gcd, lcm, primes, modular arithmetic](math/nt-basics.md), [sequences](math/sequences.md)  
- [Arrays & strings basics](fundamentals/strings-arrays.md)  
- [Problem-solving mindset (reading problems, testing with examples)](fundamentals/problem-solving.md) 
- [Debugging practices](fundamentals/debugging.md)  
- [Introduction to proof writing in mathematics](math/proof-writing.md)  

---

## Phase 2 – First Data Structures & Problem-Solving Tools

- [Prefix sums, difference arrays](algorithms/prefix-sums.md)  
- [Stacks, queues, deques, linked lists](data-structures/linear-ds.md)  
- [`std::sort`, custom comparators](fundamentals/builtin-sorting.md)
- Two pointers  
- Simple greedy strategies + proof of correctness + Mathematical Induction  
- Geometry basics: Dot/Cross Product, Manhattan Distance, Euclidean Distance  
- Floating point number representation  
- Radix conversion  
- Binary search on arrays  

---

## Phase 3 – Brute Force, Recursion & Intro to Graphs/DP

- Brute force & complexity limits  
- Sorting techniques: $O(n^2)$ sorts, Radix sort, Bucket sort
- Recursion
- Backtracking (N-queens, permutations)  
- Bitmasks for subsets  
- Divisibility, Sieve of Eratosthenes, factorization in $O(\sqrt{n})$  
- Binary search on answer  
- Binary exponentiation  
- Interactive problems  
- [Intro to DP: Fibonacci, Coin Change](algorithms/dp.md)  
- Graph representation: adjacency list vs. matrix  
- Connected components  

---

## Phase 4 – Intermediate DS & DP

- Sets, multisets, hashmaps, policy-based DS  
- Coordinate compression  
- Pointers & Iterators  
- Trees (DFS, BFS, properties, DP)  
- Tries  
- [Intermediate DP:](algorithms/dp.md)  
    * Grid paths  
    * Prefix DP  
    * 0/1 Knapsack  
    * Interval DP (matrix chain, merging stones)  
    * LIS (Longest Increasing Subsequence)  
- Counting & combinatorics basics (nCr, Pascal’s triangle, factorials mod, Binomial Theorem)  
- Modular Inverses & Fermat’s Little Theorem
- Game Theory Basics & Minimax  
- Line sweeping  

---

## Phase 5 – Graph Algorithms (Part I)

- BFS, DFS in depth  
- Planar Graphs, Eulerian Graphs, Hamiltonian Graphs  
- Topological Sort & Euler Tour  
- Shortest paths:  
    * Dijkstra  
    * Bellman–Ford  
    * Floyd–Warshall  

---

## Phase 6 – Divide & Conquer, Trees & DS

- Fast sorting (merge sort, quick sort)  
- Divide & conquer on problems (inversion count, Karatsuba multiplication)  
- Sparse tables, Segment Trees, Fenwick Tree, Merge Sort Tree  
- Binary heaps  
- Union-Find (DSU)  

---

## Phase 7 – Advanced Graph Algorithms

- Minimum Spanning Tree (Kruskal, Prim)  
- Binary Lifting (LCA)  
- Strongly Connected Components & Condensation graph  
- Flows (Ford–Fulkerson)  
- Bipartite Matching, Hungarian Algorithm  
- More interactive problems  
- Bridges & Articulation Points  

---

## Phase 8 – Advanced Topics

- Persistent Data Structures  
- Advanced Number Theory
    * Euler’s Totient Function  
    * Bézout’s Identity  
- Ternary search (unimodal functions)  
- Sqrt decomposition & Mo’s algorithm  
- Heavy-light decomposition  
- Centroid decomposition  
- Knuth–Yao optimization  
- Randomized Algorithms  
- Lazy propagation  
- Geometry:  
    * Convex hull  
    * Rotations & angle problems  
    * Polygon area  

---

## Final Tips

- **Consistency beats intensity**: Solve a few problems every day rather than cramming.  
- **Mix topics**: Don’t stay stuck on only one topic for months; revisit earlier phases to reinforce them.  
- **Balance theory and practice**: Understanding algorithms is important, but solving problems under time pressure matters more.  
- **Compete often**: Join Codeforces, AtCoder, and AOI contests regularly to measure your progress.  
- **Discuss with peers**: Teaching or explaining a solution to a friend helps you deeply understand it.  
- **Don’t fear hard problems**: Even if you can’t solve them, trying will push your thinking forward.  

> 🚀 Remember: becoming strong at problem-solving is not about how **fast** you progress through the roadmap, but how **deeply** you understand and apply each step.  

