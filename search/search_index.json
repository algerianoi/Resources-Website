{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the AOI Study Hub","text":"<p>The Algerian Olympiad in Informatics (AOI) Study Hub is your central resource for:</p> <ul> <li> <p>\ud83d\udcd8 Learning materials and guides  </p> </li> <li> <p>\ud83d\udcdd Editorials for AOI contests  </p> </li> <li> <p>\ud83d\udca1 Problem-solving strategies  </p> </li> <li> <p>\ud83d\udcda Recommended resources for IOI-level preparation  </p> </li> </ul> <p>Our goal is to support students in their journey through competitive programming, from their very first steps to advanced training.</p>"},{"location":"#what-youll-find-here","title":"\ud83d\udd0e What You\u2019ll Find Here","text":"<ul> <li> <p>Study Resources   A curated set of tutorials, handouts, and references covering algorithms, data structures, paradigms, and problem-solving techniques.</p> </li> <li> <p>Contest Editorials   Step-by-step explanations and solutions to AOI contest problems, helping you understand different approaches and improve your skills.</p> </li> <li> <p>Training Materials   Collections of exercises, problems, and practice contests to prepare for national and international olympiads.</p> </li> <li> <p>External Resources   Links to trusted platforms such as France-IOI, DMOJ, and CSES.</p> </li> </ul>"},{"location":"#about-aoi","title":"\ud83c\udf0d About AOI","text":"<p>The Algerian Olympiad in Informatics (AOI) is the national training program for informatics olympiads. Top contestants represent Algeria in the International Olympiad in Informatics (IOI). This site was built to centralize knowledge and make preparation accessible to everyone interested in algorithms, coding, and problem-solving.</p>"},{"location":"#contributing","title":"\ud83d\udcec Contributing","text":"<p>This hub is community-driven! - Found a mistake? - Want to add a resource or write an editorial?  </p> <p>Open a pull request on GitHub or reach out to the AOI team.  </p> <p>Together, let\u2019s grow Algeria\u2019s competitive programming community!</p>"},{"location":"roadmap/","title":"The AOI Roadmap","text":"<p>This roadmap is a recommended learning path for AOI students who want to gradually build their competitive programming and problem-solving skills.  </p> <p>\u26a0\ufe0f Important: </p> <ul> <li>Focus on problem-solving skills more than rushing to advance in the roadmap.  </li> <li>Make sure your basics are strong before moving on.  </li> <li>You are not obliged to complete the whole roadmap \u2014 it is just a suggestion of what to do next.  </li> <li>Practice a lot \u2014 solving problems consistently is the most effective way to improve.  </li> <li>Learn to write clean solutions and explain your reasoning \u2014 clarity is as important as correctness.  </li> <li>Always review your mistakes and analyze why a solution failed \u2014 this is where the real learning happens.  </li> </ul>"},{"location":"roadmap/#phase-1-foundations","title":"Phase 1 \u2013 Foundations","text":"<ul> <li>Language basics (C++): I/O, loops, conditionals, functions </li> <li>Complexity analysis (Big-O, simple cases)</li> <li>Basic math: logic, gcd, lcm, primes, modular arithmetic, sequences  </li> <li>Arrays &amp; strings basics  </li> <li>Problem-solving mindset (reading problems, testing with examples)  </li> <li>Debugging practices  </li> <li>Introduction to proof writing in mathematics </li> </ul>"},{"location":"roadmap/#phase-2-first-data-structures-problem-solving-tools","title":"Phase 2 \u2013 First Data Structures &amp; Problem-Solving Tools","text":"<ul> <li>Prefix sums, difference arrays  </li> <li>Stacks, queues, deques, linked lists  </li> <li><code>std::sort</code>, custom comparators  </li> <li>Two pointers  </li> <li>Simple greedy strategies + proof of correctness + Mathematical Induction  </li> <li>Geometry basics: Dot/Cross Product, Manhattan Distance, Euclidean Distance  </li> <li>Floating point number representation  </li> <li>Radix conversion  </li> <li>Binary search on arrays  </li> </ul>"},{"location":"roadmap/#phase-3-brute-force-recursion-intro-to-graphsdp","title":"Phase 3 \u2013 Brute Force, Recursion &amp; Intro to Graphs/DP","text":"<ul> <li>Brute force &amp; complexity limits  </li> <li>Sorting techniques: \\(O(n^2)\\) sorts, Radix sort, Bucket sort  </li> <li>Backtracking (N-queens, permutations)  </li> <li>Recursion (factorial, Fibonacci, tree traversal)  </li> <li>Bitmasks for subsets  </li> <li>Divisibility, Sieve of Eratosthenes, factorization in \\(O(\\sqrt{n})\\) </li> <li>Binary search on answer  </li> <li>Binary exponentiation  </li> <li>Interactive problems  </li> <li>Intro to DP: Fibonacci, Coin Change  </li> <li>Graph representation: adjacency list vs. matrix  </li> <li>Connected components  </li> </ul>"},{"location":"roadmap/#phase-4-intermediate-ds-dp","title":"Phase 4 \u2013 Intermediate DS &amp; DP","text":"<ul> <li>Sets, multisets, hashmaps, policy-based DS  </li> <li>Coordinate compression  </li> <li>Pointers &amp; Iterators  </li> <li>Trees (DFS, BFS, properties, DP)  </li> <li>Tries  </li> <li>Intermediate DP:  <ul> <li>Grid paths  </li> <li>Prefix DP  </li> <li>0/1 Knapsack  </li> <li>Interval DP (matrix chain, merging stones)  </li> <li>LIS (Longest Increasing Subsequence)  </li> </ul> </li> <li>Counting &amp; combinatorics basics (nCr, Pascal\u2019s triangle, factorials mod, Binomial Theorem)  </li> <li>Modular Inverses &amp; Fermat\u2019s Little Theorem</li> <li>Game Theory Basics &amp; Minimax  </li> <li>Line sweeping  </li> </ul>"},{"location":"roadmap/#phase-5-graph-algorithms-part-i","title":"Phase 5 \u2013 Graph Algorithms (Part I)","text":"<ul> <li>BFS, DFS in depth  </li> <li>Planar Graphs, Eulerian Graphs, Hamiltonian Graphs  </li> <li>Topological Sort &amp; Euler Tour  </li> <li>Shortest paths:  <ul> <li>Dijkstra  </li> <li>Bellman\u2013Ford  </li> <li>Floyd\u2013Warshall  </li> </ul> </li> </ul>"},{"location":"roadmap/#phase-6-divide-conquer-trees-ds","title":"Phase 6 \u2013 Divide &amp; Conquer, Trees &amp; DS","text":"<ul> <li>Fast sorting (merge sort, quick sort)  </li> <li>Divide &amp; conquer on problems (inversion count, Karatsuba multiplication)  </li> <li>Sparse tables, Segment Trees, Fenwick Tree, Merge Sort Tree  </li> <li>Binary heaps  </li> <li>Union-Find (DSU)  </li> </ul>"},{"location":"roadmap/#phase-7-advanced-graph-algorithms","title":"Phase 7 \u2013 Advanced Graph Algorithms","text":"<ul> <li>Minimum Spanning Tree (Kruskal, Prim)  </li> <li>Binary Lifting (LCA)  </li> <li>Strongly Connected Components &amp; Condensation graph  </li> <li>Flows (Ford\u2013Fulkerson)  </li> <li>Bipartite Matching, Hungarian Algorithm  </li> <li>More interactive problems  </li> <li>Bridges &amp; Articulation Points  </li> </ul>"},{"location":"roadmap/#phase-8-advanced-topics","title":"Phase 8 \u2013 Advanced Topics","text":"<ul> <li>Persistent Data Structures  </li> <li>Advanced Number Theory<ul> <li>Euler\u2019s Totient Function  </li> <li>B\u00e9zout\u2019s Identity  </li> </ul> </li> <li>Ternary search (unimodal functions)  </li> <li>Sqrt decomposition &amp; Mo\u2019s algorithm  </li> <li>Heavy-light decomposition  </li> <li>Centroid decomposition  </li> <li>Knuth\u2013Yao optimization  </li> <li>Randomized Algorithms  </li> <li>Lazy propagation  </li> <li>Geometry:  <ul> <li>Convex hull  </li> <li>Rotations &amp; angle problems  </li> <li>Polygon area  </li> </ul> </li> </ul>"},{"location":"roadmap/#final-tips","title":"Final Tips","text":"<ul> <li>Consistency beats intensity: Solve a few problems every day rather than cramming.  </li> <li>Mix topics: Don\u2019t stay stuck on only one topic for months; revisit earlier phases to reinforce them.  </li> <li>Balance theory and practice: Understanding algorithms is important, but solving problems under time pressure matters more.  </li> <li>Compete often: Join Codeforces, AtCoder, and AOI contests regularly to measure your progress.  </li> <li>Discuss with peers: Teaching or explaining a solution to a friend helps you deeply understand it.  </li> <li>Don\u2019t fear hard problems: Even if you can\u2019t solve them, trying will push your thinking forward.  </li> </ul> <p>\ud83d\ude80 Remember: becoming strong at problem-solving is not about how fast you progress through the roadmap, but how deeply you understand and apply each step.  </p>"},{"location":"editorials/IOI%20TST%202025/","title":"IOI TST 2025 Editorials","text":"<p>This directory contains editorials for the problems from the IOI TST 2025 contest. This contest served as a selection test to select Algeria's team in the International Olympiad in Informatics (IOI) 2025.</p>"},{"location":"editorials/IOI%20TST%202025/#problems","title":"Problems","text":"<ul> <li>Temperature</li> <li>Turtles</li> <li>Quantum</li> <li>Goal</li> <li>Xoracle</li> <li>Train</li> <li>Sequence</li> <li>Zeckendorf</li> </ul>"},{"location":"editorials/IOI%20TST%202025/#contest-organizers-and-contributors","title":"Contest organizers and contributors","text":"<ul> <li>Raouf Ould Ali</li> <li>Firas Mohammed El Amine Kiram</li> <li>Chams Eddine Abdelali Derreche</li> <li>Raihane Sidhoum</li> <li>Aboubakr Bendahmane</li> <li>Assil Abderezzak Boukhennoufa</li> <li>Mohamed Boukra</li> </ul>"},{"location":"editorials/IOI%20TST%202025/goal/","title":"Goal","text":""},{"location":"editorials/IOI%20TST%202025/goal/#problem-statement","title":"Problem Statement","text":"<ul> <li> <p>English</p> </li> <li> <p>French</p> </li> <li> <p>Arabic</p> </li> </ul>"},{"location":"editorials/IOI%20TST%202025/goal/#solution","title":"Solution","text":"<p>In this problem we have to find the shortest path to get to the final cell.</p> <p>We have an $n \\times m $ grid and we will start in the cell $ (1,1) $ and we want to get into the final cell which is $ (n,m) $.</p> <p>Each cell is one of the following:</p> <p>When you end a row in the grid, you start in the beginning of the next row.</p> <p>Find the shortest path from the point $ (1,1) $ to the point $ (n,m) $ or print $ -1 $ if there is no such path.</p> <p>A general idea before we go to the solution: we can get rid of the grid and make a 1D line.</p>"},{"location":"editorials/IOI%20TST%202025/goal/#subtask-1-15-points","title":"Subtask 1: 15 points","text":"<p>Each cell is either an empty cell or an obstacle.</p> <ul> <li>If there is an obstacle, the answer is \\(-1\\) because we won't be able   to reach the cell $ (n,m) $.</li> <li>Otherwise, the answer is $ n \\times m - 1 $.</li> </ul>"},{"location":"editorials/IOI%20TST%202025/goal/#subtask-2-20-points","title":"Subtask 2: 20 points","text":"<p>Not sure what the intended solution is, but maybe try all ways using DFS (likely TLE).</p>"},{"location":"editorials/IOI%20TST%202025/goal/#subtask-3-25-points","title":"Subtask 3: 25 points","text":"<p>This idea covers subtasks 2 and 3.</p> <p>We can go from the end and solve it using DP:</p> <ul> <li>Empty cell \u2192 move forward by 1 step.</li> <li>Obstacle \u2192 push 2 cells backward.</li> <li>Booster cell  \u2192 jump forward by the digit (if valid), or   move 1 step forward.</li> </ul> <p>If booster goes out of grid, ignore it. Base case: $ dp(n \\times m - 1) = 0 $. Answer: $ dp(0) $. Time complexity: $ O(n \\times m ) $.</p>"},{"location":"editorials/IOI%20TST%202025/goal/#subtask-4-100-points","title":"Subtask 4: 100 points","text":"<p>Run BFS from the start cell.</p> <ul> <li>Check if visited.</li> <li>Maintain number of steps in BFS.</li> <li>Answer is in $ (n,m) $ or $ -1 $ if unreachable.</li> </ul> <p>Time complexity: $ O(n \\times m ) $.</p>"},{"location":"editorials/IOI%20TST%202025/goal/#implementation","title":"Implementation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define pb push_back\n#define ll long long\n\nvoid solve() {  \n    int n , m;\n    cin &gt;&gt; n &gt;&gt; m;\n    string s = {};\n    for(int i = 0 ; i &lt; n ; i ++) {\n        string a;cin &gt;&gt; a; s += a;\n    }\n    vector &lt; ll &gt; d(n * m , 1e16);\n    queue &lt;ll&gt; q; d[0] = 0;\n    q.push(0);\n    while(!q.empty()) {\n        ll pos = q.front() ; q.pop();\n        if(pos == n * m - 1) return void(cout &lt;&lt; d[pos] &lt;&lt; '\\n');\n        if(pos - 2 &gt;= 0 &amp;&amp; s[pos] == '#') {\n            if(d[pos - 2] &gt; d[pos] + 1)\n                d[pos - 2] = d[pos] + 1 , q.push(pos - 2);\n            continue;\n        }\n        if(pos + 1 &lt; n * m)\n            if(d[pos + 1] &gt; d[pos] + 1)\n                d[pos + 1] = d[pos] + 1 , q.push(pos + 1);\n        if(s[pos] == '.') continue;\n        int nex = pos + (s[pos] - '0');\n        if(nex &lt; n * m)\n            if(d[nex] &gt; d[pos] + 1)\n                d[nex] = d[pos] + 1 , q.push(nex);        \n    }\n    cout &lt;&lt; \"-1\";\n}\n\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL);\n    solve(); \n    return 0;\n}\n</code></pre>"},{"location":"editorials/IOI%20TST%202025/quantum/","title":"Quantum","text":""},{"location":"editorials/IOI%20TST%202025/quantum/#problem-statement","title":"Problem Statement","text":"<ul> <li> <p>English</p> </li> <li> <p>French</p> </li> <li> <p>Arabic</p> </li> </ul>"},{"location":"editorials/IOI%20TST%202025/quantum/#solution","title":"Solution","text":"<p>We have an $n \\times m $ grid, initially empty. We will be given \\(C\\) points. Each time we add a point, we must choose a point \\((x,y)\\) in the grid such that the sum of distances from all added points to \\((x,y)\\) is minimized.</p>"},{"location":"editorials/IOI%20TST%202025/quantum/#subtask-1-5-points","title":"Subtask 1: 5 points","text":"<p>Grid is $ 1 \\times 2 $. Just check whether \\((1,1)\\) or \\((1,2)\\) is better.</p>"},{"location":"editorials/IOI%20TST%202025/quantum/#subtask-2-15-points","title":"Subtask 2: 15 points","text":"<p>Use a 2D array initialized to zeros. For each new point \\((x,y)\\):</p> <ul> <li>Add distance to all cells.</li> <li>Take minimum.</li> </ul> <p>Time complexity: $ O( n \\times m \\times c ) $.</p>"},{"location":"editorials/IOI%20TST%202025/quantum/#subtask-3-30-points","title":"Subtask 3: 30 points","text":"<p>We use a greedy/median idea.</p> <p>For 1D: given $ X_1, X_2, \\dots $, to minimize $ \\sum|X_i - v| $, pick median. So:</p> <ul> <li>Maintain arrays of $ x $'s and $ y $'s separately.</li> <li>Each time, sort them, pick median, compute sum of distances.</li> </ul> <p>Time complexity: $ O( c^2 \\log{c} ) $.</p>"},{"location":"editorials/IOI%20TST%202025/quantum/#subtask-4-100-points","title":"Subtask 4: 100 points","text":"<p>Optimize subtask 3 with data structures:</p> <ul> <li>Ordered set \u2192 find median in $ O( \\log{c} ) $.</li> <li>Lazy segment tree \u2192 range update/query for sums.</li> </ul> <p>Final complexity: $ O(c \\times ( \\log{c} + \\log{n} + \\log{m} )  ) $ .</p>"},{"location":"editorials/IOI%20TST%202025/quantum/#implementation","title":"Implementation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n#include &lt;filesystem&gt;\nusing namespace std;\nusing ll = long long;\n\n// Segment tree for sum over a fixed range [1..N]\nstruct SegTree {\n    int n;\n    vector&lt;ll&gt; t;\n    SegTree(int _n): n(_n), t(4*n, 0) {}\n    void update(int idx, ll val, int v, int tl, int tr) {\n        if (tl == tr) {\n            t[v] += val;\n        } else {\n            int tm = (tl + tr) &gt;&gt; 1;\n            if (idx &lt;= tm) update(idx, val, v&lt;&lt;1, tl, tm);\n            else          update(idx, val, v&lt;&lt;1|1, tm+1, tr);\n            t[v] = t[v&lt;&lt;1] + t[v&lt;&lt;1|1];\n        }\n    }\n    void update(int idx, ll val) { update(idx, val, 1, 1, n); }\n    ll query(int l, int r, int v, int tl, int tr) {\n        if (l &gt; r) return 0;\n        if (l == tl &amp;&amp; r == tr) return t[v];\n        int tm = (tl + tr) &gt;&gt; 1;\n        return query(l, min(r, tm), v&lt;&lt;1, tl, tm)\n             + query(max(l, tm+1), r, v&lt;&lt;1|1, tm+1, tr);\n    }\n    ll query(int l, int r) { return query(l, r, 1, 1, n); }\n};\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, m, C;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; C;\n    vector&lt;int&gt; xs(C), ys(C);\n    for(int i=0;i&lt;C;i++) cin&gt;&gt;xs[i]&gt;&gt;ys[i];\n\n    // Create segment trees for X and Y: counts and sums\n    SegTree cntX(n), sumX(n);\n    SegTree cntY(m), sumY(m);\n\n    vector&lt;ll&gt; ans(C);\n\n    for(int k=1;k&lt;=C;k++){\n        int x = xs[k-1], y = ys[k-1];\n        cntX.update(x, 1);\n        sumX.update(x, x);\n        cntY.update(y, 1);\n        sumY.update(y, y);\n\n        // total count and sum\n        ll totalX = sumX.query(1, n);\n        ll totalCntX = cntX.query(1, n);\n        auto costX = [&amp;](int X){\n            ll leftCnt  = cntX.query(1, X);\n            ll leftSum  = sumX.query(1, X);\n            ll rightCnt = totalCntX - leftCnt;\n            ll rightSum = totalX - leftSum;\n            return X*leftCnt - leftSum + rightSum - X*rightCnt;\n        };\n\n        // Ternary search on [1..n]\n        int l = 1, r = n;\n        while(r - l &gt; 3){\n            int m1 = l + (r - l)/3;\n            int m2 = r - (r - l)/3;\n            if(costX(m1) &gt; costX(m2)) l = m1;\n            else r = m2;\n        }\n        ll bestX = LLONG_MAX;\n        for(int X=l; X&lt;=r; ++X) bestX = min(bestX, costX(X));\n\n        // Similarly for Y\n        ll totalY = sumY.query(1, m);\n        ll totalCntY = cntY.query(1, m);\n        auto costY = [&amp;](int Y){\n            ll lc = cntY.query(1, Y);\n            ll ls = sumY.query(1, Y);\n            ll rc = totalCntY - lc;\n            ll rs = totalY - ls;\n            return Y*lc - ls + rs - Y*rc;\n        };\n        l = 1; r = m;\n        while(r - l &gt; 3){\n            int m1 = l + (r - l)/3;\n            int m2 = r - (r - l)/3;\n            if(costY(m1) &gt; costY(m2)) l = m1;\n            else r = m2;\n        }\n        ll bestY = LLONG_MAX;\n        for(int Y=l; Y&lt;=r; ++Y) bestY = min(bestY, costY(Y));\n\n        ans[k-1] = bestX + bestY;\n    }\n\n    for(ll v: ans) cout&lt;&lt;v&lt;&lt;\"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"editorials/IOI%20TST%202025/sequence/","title":"Sequence","text":""},{"location":"editorials/IOI%20TST%202025/sequence/#problem-statement","title":"Problem Statement","text":"<ul> <li>English </li> <li>French </li> <li>Arabic </li> </ul>"},{"location":"editorials/IOI%20TST%202025/sequence/#full-solution","title":"Full Solution","text":""},{"location":"editorials/IOI%20TST%202025/sequence/#step-1-split-the-array","title":"Step 1: Split the array","text":"<p>Divide \\(A\\) into two halves:</p> <ul> <li>\\(a\\) = first \\(\\lceil N/2 \\rceil\\) elements  </li> <li>\\(b\\) = last \\(\\lfloor N/2 \\rfloor\\) elements  </li> </ul> <p>We will enumerate all subsequences of \\(a\\) and \\(b\\) separately.</p>"},{"location":"editorials/IOI%20TST%202025/sequence/#step-2-enumerate-subsequences-with-states","title":"Step 2: Enumerate subsequences with states","text":"<p>For each subset of a half:</p> <ul> <li>Compute its sum.  </li> <li>Track the number of consecutive negatives.  </li> <li>Track whether the subsequence started with negatives (important for merging).  </li> </ul> <p>Specifically, we maintain:</p> <ul> <li><code>con_neg</code>: the maximum run of consecutive negatives inside the subsequence.  </li> <li><code>first_neg</code>: number of negatives before the first positive (so we know how many negatives \"lead\" the subsequence).  </li> </ul> <p>If <code>con_neg</code> \\(\\leq 3\\), the subsequence is valid for its half. We insert its sum into a container indexed by <code>first_neg</code>.  </p>"},{"location":"editorials/IOI%20TST%202025/sequence/#step-3-meet-in-the-middle","title":"Step 3: Meet in the middle","text":"<p>Now, when enumerating subsets of \\(b\\), we again compute <code>con_neg</code> and how the sequence ends (trailing negatives). To combine with a subset from \\(a\\), we must ensure that the run of negatives crossing the boundary does not exceed 3.  </p> <p>Thus:</p> <ul> <li>If \\(b\\) ends with \\(x\\) negatives, we can only merge with subsets of \\(a\\) that begin with \\(\\leq 3 - x\\) negatives.  </li> </ul> <p>This check guarantees the global subsequence never contains 4 consecutive negatives.</p>"},{"location":"editorials/IOI%20TST%202025/sequence/#step-4-minimization","title":"Step 4: Minimization","text":"<p>For each valid sum from \\(b\\), we search in the precomputed sums of \\(a\\) (stored in sets for fast lookup). We want the smallest <code>sum_a</code> \\(+\\) <code>sum_b</code> \\(\\geq S\\). This is done with a lower bound query.</p>"},{"location":"editorials/IOI%20TST%202025/sequence/#step-5-answer","title":"Step 5: Answer","text":"<ul> <li>If no valid pair was found, print <code>Impossible</code>.  </li> <li>Otherwise, print the minimum sum found.</li> </ul>"},{"location":"editorials/IOI%20TST%202025/sequence/#complexity","title":"Complexity","text":"<p>\\(O(N \\cdot 2^{\\frac{N}{2}})\\)</p>"},{"location":"editorials/IOI%20TST%202025/sequence/#subtasks","title":"Subtasks","text":"<ul> <li>Subtask 1 (15 pts): Elements are only \\(1\\) or \\(-1\\). Can brute force all subsequences.  </li> <li>Subtask 2 (15 pts): \\(N \\leq 5\\). Exhaustive \\(2^N\\) works.  </li> <li>Subtask 3 (30 pts): \\(N \\leq 18\\). Direct brute force over the array is feasible.  </li> </ul>"},{"location":"editorials/IOI%20TST%202025/sequence/#implementation","title":"Implementation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main () {\n\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n\n  int n;\n  long long s;\n  cin &gt;&gt; n &gt;&gt; s;\n  vector&lt;int&gt; a((n + 1) / 2), b(n / 2);\n  for (int i = 0; i &lt; (n + 1) / 2; ++i) {\n    cin &gt;&gt; a[i];\n  } \n  for (int i = 0; i &lt; n / 2; ++i) {\n    cin &gt;&gt; b[i];\n  }\n  swap(a, b);\n  vector&lt;set&lt;long long&gt;&gt; meet(4);\n  for (int mask = 0; mask &lt; (1 &lt;&lt; a.size()); ++mask) {\n    int con_neg = 0, first_pos = 0, first_neg = 0, cur_neg = 0;\n    long long sum = 0;\n    for (int i = 0; i &lt; a.size(); ++i) {\n      if (mask &gt;&gt; i &amp; 1) {\n        sum += a[i];\n        if (a[i] &lt; 0) {\n          if (!first_pos) {\n            ++first_neg;\n          }\n          con_neg = max(con_neg, ++cur_neg);\n        }\n        else {\n          first_pos = 1;\n          con_neg = max(con_neg, cur_neg);\n          cur_neg = 0;\n        }\n      }\n    }\n    if (con_neg &lt;= 3) {\n      meet[first_neg].insert(sum);\n    }\n  }\n  long long ans = 9e18;\n  for (int mask = 0; mask &lt; (1 &lt;&lt; b.size()); ++mask) {\n    int con_neg = 0, cur_neg = 0;\n    long long sum = 0;\n    for (int i = 0; i &lt; b.size(); ++i) {\n      if (mask &gt;&gt; i &amp; 1) {\n        sum += b[i];\n        if (b[i] &lt; 0) {\n          con_neg = max(con_neg, ++cur_neg);\n        }\n        else {\n          con_neg = max(con_neg, cur_neg);\n          cur_neg = 0;\n        }\n      }\n    }\n    if (con_neg &lt;= 3) {\n      for (int k = 0; k + cur_neg &lt;= 3; ++k) {\n        auto it = meet[k].lower_bound(s - sum);\n        if (it != meet[k].end()) {\n          ans = min(ans, sum + *it);\n        }\n      }\n    }\n  }\n  if (ans == (long long)9e18) {\n    cout &lt;&lt; \"Impossible\";\n  }\n  else {\n    cout &lt;&lt; ans;\n  }\n\n  return 0;\n}\n</code></pre>"},{"location":"editorials/IOI%20TST%202025/temperature/","title":"Temperature","text":""},{"location":"editorials/IOI%20TST%202025/temperature/#problem-statement","title":"Problem Statement","text":"<ul> <li>English</li> <li>French</li> <li>Arabic</li> </ul>"},{"location":"editorials/IOI%20TST%202025/temperature/#solution","title":"Solution","text":"<p>We have the values of \\(V\\) and we want to compute the values of \\(T\\) as follows:</p> \\[ T_i = \\begin{cases} 0 &amp; \\text{if } i = 0 \\\\ T_{i-1} + V_{i-1} &amp; \\text{if } i \\geq 1 \\end{cases} \\] <p>Once we compute the values of \\(T\\), we want the final answer:</p> <p>$ mx = \\max_{0 \\leq i &lt; j \\leq n} T_j - T_i $</p>"},{"location":"editorials/IOI%20TST%202025/temperature/#subtask-1-2-60-points","title":"Subtask 1 &amp; 2: 60 points","text":"<p>We can use two nested loops and find the maximum among all pairs $ (i, j) $ in the array \\(T\\).</p>"},{"location":"editorials/IOI%20TST%202025/temperature/#subtask-3-100-points","title":"Subtask 3: 100 points","text":"<p>To maximize the answer for any \\(j\\) from 1 to \\(n-1\\), we need to subtract it from the minimum value in the range $ [0, j-1] $. We can maintain this minimum value while iterating.</p> <p>Let: </p> <ul> <li> <p><code>mn</code> = minimum value seen so far (initially $ 1e18 $).</p> </li> <li> <p><code>mx</code> = best answer so far (initially 0)</p> </li> </ul> <p>For each \\(i\\): </p> <ul> <li> <p>$ mn = \\min(mn, T_i) $.</p> </li> <li> <p>$ mx = \\max(mx, T_i - mn) $.</p> </li> </ul> <p>At the end, the answer is in <code>mx</code>.</p> <p>Print <code>mx</code> and congrats, you got 100 points!</p>"},{"location":"editorials/IOI%20TST%202025/temperature/#implementation","title":"Implementation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\ntypedef long long ll;\nusing namespace std;\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    ll n;\n    cin &gt;&gt; n;\n    vector&lt;ll&gt; a(n+1, 0);\n    for(ll i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];\n    ll mini = 0;\n    ll current = 0;\n    ll res = 0;\n    for(auto t : a){\n        current += t;\n        res = max(res, current - mini);\n        mini = min(current, mini);\n    }\n    cout &lt;&lt; res &lt;&lt; '\\n';\n\n}\n</code></pre>"},{"location":"editorials/IOI%20TST%202025/train/","title":"Train","text":""},{"location":"editorials/IOI%20TST%202025/train/#problem-statement","title":"Problem Statement","text":"<ul> <li>English</li> <li>French</li> <li>Arabic</li> </ul>"},{"location":"editorials/IOI%20TST%202025/train/#full-solution","title":"Full Solution","text":"<p>Let \\(a_1, a_2, \\dots, a_C\\) be the weights of the cargo, sorted from largest to smallest. Extend this sequence by adding zeros until we have \\(2W\\) terms, i.e.,  </p> <p>\\(a_{C+1} = a_{C+2} = \\dots = a_{2W} = 0.\\) </p> <p>Then the minimum imbalance, \\(I_{\\min}\\), is  </p> <p>\\(I_{\\min} = |A - (a_1 + a_{2W})| + |A - (a_2 + a_{2W-1})| + \\dots + |A - (a_W + a_{W+1})|,\\) </p> <p>which corresponds to the imbalance resulting from putting \\((a_i, a_{2W+1-i})\\) in the \\(i\\)th cargo, for \\(1 \\le i \\le W\\). (If \\(j &gt; C\\), the spot is left empty.)</p> <p>We now show that this partition gives the minimum. Suppose two cargos contain \\(a_i, a_j, a_k, a_l\\) in some partition, with  </p> <p>\\(a_i \\ge a_j \\ge a_k \\ge a_l.\\) </p> <p>Let  </p> <p>\\(S = \\frac{a_i + a_j + a_k + a_l}{2}, \\quad U = \\left|\\frac{X_1 - X_2}{2}\\right|.\\) </p> <p>Then the total imbalance is  </p> <p>\\(|A + S + U| + |A + S - U|.\\) </p> <p>Notice that this function, as a function of \\(U\\), is increasing for \\(U \\in [0, +\\infty)\\). Therefore, the smaller \\(U\\) is, the smaller the imbalance. It is clear that the partition  </p> <p>\\((a_i, a_l), \\quad (a_j, a_k)\\) </p> <p>minimizes \\(U\\).</p>"},{"location":"editorials/IOI%20TST%202025/train/#proof-of-minimization","title":"Proof of minimization","text":"<p>There are three possible partitions of four elements:  </p> <p>\\((a_i, a_j), (a_k, a_l)\\), \\((a_i, a_k), (a_j, a_l)\\), \\((a_i, a_l), (a_j, a_k)\\).  </p> <p>These give  </p> <p>\\(U_1 = a_i + a_j - a_k - a_l, \\quad   U_2 = |a_i - a_j + a_k - a_l|, \\quad   U_3 = |a_i - a_j - (a_k - a_l)|.\\) </p> <p>Hence, \\(U\\) is minimized by the last partition, seeing as \\(U_1 \\geq U_2 \\geq U_3\\).</p> <p>Taking any two wagons, we can improve the total imbalance by adjusting the partition of the four elements in \\(W_1 \\cup W_2\\) according to the lemma. Consider the wagon containing \\(a_1\\) and the wagon containing \\(a_{2W}\\). If they are distinct, applying the partition lemma shows it is optimal for the wagon with \\(a_1\\) to contain \\(a_{2W}\\). Otherwise, we skip this step.</p>"},{"location":"editorials/IOI%20TST%202025/train/#induction-step","title":"Induction step","text":"<p>Assume the wagons containing \\(a_1, \\dots, a_{i-1}\\) already contain \\(a_{2W}, \\dots, a_{2W+2-i}\\) as their second cargo, respectively. If the wagon containing \\(a_i\\) does not contain \\(a_{2W+1-i}\\), we swap contents with the wagon that does. By the partition lemma, this is optimal. By induction, we reach the proposed initial partition, which is unique.</p>"},{"location":"editorials/IOI%20TST%202025/train/#algorithm","title":"Algorithm","text":"<ol> <li>Create a vector containing all cargo weights and add zeros until its length is \\(2W\\).</li> <li>Sort the vector.</li> <li>Compute the average  </li> </ol> <p>\\(A = \\frac{\\text{sum of all elements}}{C}.\\) </p> <ol> <li>Initialize \\(ans = 0\\). For \\(i = 0\\) to \\(W-1\\), increase \\(ans\\) by  </li> </ol> <p>\\(|a_i + a_{2W-1-i} - A|.\\) </p> <ol> <li>Output \\(ans\\) as the minimum imbalance.</li> </ol> <p>This algorithm runs in \\(O(2W \\log(2W))\\), which can be optimized to \\(O(C \\log C)\\) by sorting first and then adding zeros in reverse order.</p>"},{"location":"editorials/IOI%20TST%202025/train/#subtasks","title":"Subtasks","text":"<ul> <li>Subtask 1: Using backtracking, iterate through all possible distributions and find the one with minimum imbalance.   Complexity: \\(O(C W^C)\\).</li> </ul>"},{"location":"editorials/IOI%20TST%202025/train/#implementation","title":"Implementation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int W, C;\n    cin &gt;&gt; W &gt;&gt; C;\n    vector&lt;long long&gt; M;\n    M.reserve(2 * W);\n    long long sum = 0;\n    for (int i = 0; i &lt; C; ++i) {\n        long long x;\n        cin &gt;&gt; x;\n        M.push_back(x);\n        sum += x;\n    }\n    // Pad with zeros to have exactly 2W elements\n    while ((int)M.size() &lt; 2 * W) {\n        M.push_back(0);\n    }\n    sort(M.begin(), M.end());\n\n    long long A = sum / W;\n    long long imbalance = 0;\n    for (int i = 0; i &lt; W; ++i) {\n        long long load = M[i] + M[2 * W - 1 - i];\n        imbalance += llabs(load - A);\n    }\n\n    cout &lt;&lt; imbalance &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>"},{"location":"editorials/IOI%20TST%202025/turtles/","title":"Turtles","text":""},{"location":"editorials/IOI%20TST%202025/turtles/#problem-statement","title":"Problem Statement","text":"<ul> <li>English</li> <li>French</li> <li>Arabic</li> </ul>"},{"location":"editorials/IOI%20TST%202025/turtles/#solution","title":"Solution","text":"<p>We have two arrays and we want to make them equal with the minimum number of operations. Operation: change current number to its greatest proper divisor (largest divisor smaller than it).</p>"},{"location":"editorials/IOI%20TST%202025/turtles/#subtask-1-8-points","title":"Subtask 1: 8 points","text":"<p>Brute force all possible arrays, check minimum operations.</p>"},{"location":"editorials/IOI%20TST%202025/turtles/#subtask-2-12-points","title":"Subtask 2: 12 points","text":"<p>All numbers are prime or \\(1\\). - Greatest proper divisor of a prime is \\(1\\). - Count occurrences of each prime in both arrays. - Answer = sum of absolute differences.</p> <p>Example:</p> <ul> <li> <p>$ A $ = <code>1 1 2 3 5 5</code></p> </li> <li> <p>$ B $ = <code>1 2 2 5 7 11</code></p> </li> <li> <p>Answer = $ | occA[p] - occB[p]| $ summed over primes.</p> </li> </ul>"},{"location":"editorials/IOI%20TST%202025/turtles/#subtask-3-10-points","title":"Subtask 3: 10 points","text":"<p>All numbers are powers of two.</p> <ul> <li> <p>Sort both arrays.</p> </li> <li> <p>For each \\(i\\), divide larger of \\(A_i, B_i\\) until it matches smaller, counting steps.</p> </li> <li> <p>GPD of power of two is always half.</p> </li> </ul>"},{"location":"editorials/IOI%20TST%202025/turtles/#subtask-5-100-points","title":"Subtask 5: 100 points","text":"<p>(Skipping subtask 4).</p> <p>Greedy approach:  - Need fast GPD calculation \u2192 precompute with sieve.</p> <ul> <li> <p>Use priority queues for A and B.</p> </li> <li> <p>While not empty:</p> </li> <li> <p>Compare max of both.</p> </li> <li> <p>If equal \u2192 pop both.</p> </li> <li> <p>Else \u2192 replace larger with its GPD, increment ops.</p> </li> </ul> <p>Time complexity: $ O(C \\log{C} ) $, where $ C \\leq 10^6 $.</p>"},{"location":"editorials/IOI%20TST%202025/turtles/#implementation","title":"Implementation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\ntypedef long long ll;\nusing namespace std;\n\nll turtles(int n, vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b)\n{\n    vector&lt;int&gt; sieve(1e6 + 1, 1);\n    for (int i = 2; i &lt;= 1e6; i++)\n    {\n        for (int j = 2; (ll)j * (ll)i &lt;= 1e6; j++)\n        {\n            sieve[i * j] = max(sieve[i * j], i);\n        }\n    }\n\n    multiset&lt;int&gt; A;\n    multiset&lt;int&gt; B;\n    for (auto x : a)\n        A.insert(x);\n    for (auto x : b)\n        B.insert(x);\n    ll cost = 0;\n    while (A.size())\n    {\n        if (*A.rbegin() == *B.rbegin())\n        {\n            A.erase(--A.end());\n            B.erase(--B.end());\n        }\n        else if (*A.rbegin() &gt; *B.rbegin())\n        {\n            A.insert(sieve[*A.rbegin()]);\n            A.erase(--A.end());\n            cost++;\n        }\n        else\n        {\n            B.insert(sieve[*B.rbegin()]);\n            B.erase(--B.end());\n            cost++;\n        }\n    }\n\n    return cost;\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; a(n);\n    vector&lt;int&gt; b(n);\n    for (int i = 0; i &lt; n; i++)\n        cin &gt;&gt; a[i];\n    for (int i = 0; i &lt; n; i++)\n        cin &gt;&gt; b[i];\n    cout &lt;&lt; turtles(n, a, b) &lt;&lt; '\\n';\n}\n</code></pre>"},{"location":"editorials/IOI%20TST%202025/xoracle/","title":"Xoracle","text":""},{"location":"editorials/IOI%20TST%202025/xoracle/#problem-statement","title":"Problem Statement","text":"<ul> <li>English</li> <li>French</li> <li>Arabic</li> </ul>"},{"location":"editorials/IOI%20TST%202025/xoracle/#subtask-1-limited-degrees","title":"Subtask 1, limited degrees","text":"<p>We are guaranteed that each node has degree at most 3, and that there exist at least one node with degree 1, 2, and 3 respectively. Note that for any number \\(d\\), there exist no positive integer \\(x\\) such that \\(d \\oplus x = d\\).  As such, we can deduce the degree of node 1, by querying <code>? 1 i</code> for each \\(i \\in [2, 3, .., N]\\) and noting what result isn't returned at any point. Once we know the degree of node 1, we can easily find the degree of any other node, since we already know \\(deg(1) \\oplus deg(i)\\), by using the following property of XOR: \\(a \\oplus a \\oplus b = b\\).</p>"},{"location":"editorials/IOI%20TST%202025/xoracle/#subtask-2-limited-degrees-2","title":"Subtask 2, limited degrees 2","text":"<p>We are guaranteed that each node has degree at most 4, and that at least 3 of the possible degrees are present in the tree. By realizing that if node 1 has degree 1, all query answers will be in the set \\(0, 3, 2, 5\\).</p> <p>Similar patterns can be seen for the other possible degrees, giving us the following combinations</p> <ul> <li>\\(1 : {0, 3, 2, 5}\\)</li> <li>\\(2 : {3, 0, 1, 6}\\)</li> <li>\\(3 : {2, 1, 0, 7}\\)</li> <li>\\(4 : {5, 6, 7, 0}\\)</li> </ul> <p>By checking the cases with the giving answers, we can find the degree of node 1, and construct the solution as in subtask 1.</p>"},{"location":"editorials/IOI%20TST%202025/xoracle/#subtask-3-n-leq-1000-q-n-n","title":"Subtask 3, \\(N \\leq 1000\\), \\(Q = N * N\\)","text":"<p>With \\(Q = N * N\\), we have enough queries to recieve as much information as we want.</p> <p>So, how can we construct the tree using the queries in time \\(O(N^2)\\)?</p> <p>We realize that at least one node must be a leaf. If we iterate over each node, and guess that this node is a leaf, we can calculate the total degree over all nodes of the tree. We now that this number needs to equal \\(2 * N - 2\\) if the graph needs to be a valid tree. There is a second condition, however, which several contestants forgot. You need to check whether any node has degree 0, in the proposed solution. If so, the graph isn't connected, and furthermore it contains at least 1 cycle, and as such isn't a valid tree.</p> <p>These 2 conditions are sufficient to construct the tree, and as such we have our solution to this subtask.</p>"},{"location":"editorials/IOI%20TST%202025/xoracle/#subtask-4-n-leq-1000-q-leq-n-sqrtn","title":"Subtask 4, \\(N \\leq 1000\\), \\(Q \\leq N \\sqrt{N}\\)","text":"<p>In this subtask we have fewer available queries than subtask 3. As such we have to observe, that if we at some point query \\(i\\) and \\(j\\), and recieve the answer 0, node \\(i\\) and \\(j\\) must have the same degree. As such we say they are in the same \"group\". When we want to query two nodes, we can instead query any two nodes from the corresponding groups. By observing, that the number of groups is O(\\sqrt{N}) we have reduced the problem to subtask 3.</p>"},{"location":"editorials/IOI%20TST%202025/xoracle/#subtask-5-n-leq-1000-q-n-1","title":"Subtask 5, \\(N \\leq 1000\\), \\(Q = N - 1\\)","text":"<p>By using the property of XOR used in subtask 1, we have reduced this subtask to subtask 3</p>"},{"location":"editorials/IOI%20TST%202025/xoracle/#subtask-6-n-leq-105","title":"Subtask 6, \\(N \\leq 10^5\\)","text":"<p>By observing that the group of nodes representing the leaves (degree 1) is either the largest or second largest group, we can use our solution to subtask 5, but running in linear time.</p>"},{"location":"editorials/IOI%20TST%202025/xoracle/#implementation","title":"Implementation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int N, Q; cin &gt;&gt; N &gt;&gt; Q;\n    vector&lt;int&gt; cnt(N+1, 0);\n    cnt[0] = 1;\n    for (int i = 1; i &lt; N; i++) {\n        cout &lt;&lt; \"? 1 \" &lt;&lt; i+1 &lt;&lt; endl;\n        int x; cin &gt;&gt; x;\n        cnt[x]++;\n    }\n    int mx = 0, sec = 1;\n    if (cnt[0] &lt; cnt[1]) swap(mx, sec);\n    for (int i = 2; i &lt; N+1; i++) {\n        if (cnt[i] &gt; cnt[mx]) {\n            sec = mx;\n            mx = i;\n        }\n        else if (cnt[i] &gt; cnt[sec]) sec = i;\n    }\n    for (auto x : {mx, sec}) {\n        int sm = 0;\n        bool flag = 0;\n        for (int i = 0; i &lt; N+1; i++) {\n            sm += cnt[i] * (i ^ x ^ 1);\n            flag |= cnt[i] &gt; 0 &amp;&amp; !(i ^ x ^ 1);\n        }\n        if (sm != 2 * N - 2 || flag) continue;\n        cout &lt;&lt; '!';\n        for (int i = 0; i &lt; N+1; i++)\n            while(cnt[i]--)\n                cout &lt;&lt; ' ' &lt;&lt; (i ^ x ^ 1);\n        cout &lt;&lt; endl;\n        break;\n    }\n}\n</code></pre>"},{"location":"editorials/IOI%20TST%202025/zeckendorf/","title":"Zeckendorf","text":""},{"location":"editorials/IOI%20TST%202025/zeckendorf/#problem-statement","title":"Problem Statement","text":"<ul> <li>English</li> <li>French</li> <li>Arabic</li> </ul> <p>let \\(Z(i)\\) be the zeckendorf representation of \\(i&gt;0\\) and \\(F_0 = 1\\)</p>"},{"location":"editorials/IOI%20TST%202025/zeckendorf/#subtask-1","title":"Subtask 1","text":"<p>Since \\(N_i \\leq 10\\), we can solve each case by hand and hardcode the results.  </p> <ul> <li>Observation: \\(10 &lt; F_6 = 13\\), so at most 5 digits are needed for \\(Z(N_i)\\).  </li> <li>Strategy: brute force all possible binary strings of length \\(\\leq 5\\), checking whether they correspond to valid Zeckendorf representations.  </li> <li>Complexity: \\(O(Q \\cdot 2^x \\cdot x)\\) for \\(x\\) digits, which is feasible for \\(x = 5\\).</li> </ul>"},{"location":"editorials/IOI%20TST%202025/zeckendorf/#subtask-2","title":"Subtask 2","text":"<p>We extend the idea of Subtask 1. Instead of checking all \\(2^n\\) binary strings, we only generate valid ones via recursion.  </p> <ul> <li>Fact: the number of valid binary strings of length \\(n\\) with no two consecutive \\(1\\)s is \\(F_{n+1}\\) (with our shifted definition).  </li> <li>Thus, the complexity is  </li> </ul> \\[ O(Q \\cdot F_{n+1} \\cdot n). \\]"},{"location":"editorials/IOI%20TST%202025/zeckendorf/#full-solution","title":"Full Solution","text":"<p>We use a greedy approach:</p> <ol> <li>Given \\(N &gt; 0\\), find the largest Fibonacci number \\(F_k \\leq N\\).  </li> <li>Set digit \\(d_k := 1\\), and update \\(N := N - F_k\\).  </li> <li>Repeat until \\(N = 0\\).  </li> </ol> <p>This procedure constructs the Zeckendorf representation of \\(N\\).  </p>"},{"location":"editorials/IOI%20TST%202025/zeckendorf/#proof-of-correctness","title":"Proof of Correctness","text":"<p>Let \\(F_k\\) be the largest Fibonacci number \\(\\leq N\\). Then:  </p> <ul> <li>By definition, \\(F_{k+1} &gt; N\\).  </li> <li>Since \\(F_{k+1} = F_k + F_{k-1}\\), we have  </li> </ul> \\[ N &lt; F_k + F_{k-1} \\implies N - F_k &lt; F_{k-1}. \\] <p>Thus, after subtracting \\(F_k\\), the remainder \\(N'\\) is strictly smaller than \\(F_{k-1}\\), meaning we will never need \\(F_{k-1}\\). This guarantees that the greedy algorithm avoids consecutive Fibonacci numbers and always produces a valid representation.  </p> <p>Uniqueness follows from the same inequality: if another representation existed with different largest Fibonacci number, it would contradict the maximality of \\(F_k\\).  </p>"},{"location":"editorials/IOI%20TST%202025/zeckendorf/#algorithm","title":"Algorithm","text":"<ol> <li>Precompute Fibonacci numbers up to the largest \\(F_k \\leq \\max(N_i)\\).  </li> <li>For each query \\(N\\):  </li> <li>Start with the largest Fibonacci number \\(\\leq N\\).  </li> <li>Subtract it and mark its digit as \\(1\\).  </li> <li>Repeat until \\(N = 0\\).  </li> <li>Output the resulting binary string.  </li> </ol> <p>Complexity: - Precomputation: \\(O(\\log N_{\\max})\\). - Each query: \\(O(\\log N)\\) since each subtraction reduces \\(N\\) by at least half in size. - Total: \\(O(Q \\log N)\\).  </p>"},{"location":"editorials/IOI%20TST%202025/zeckendorf/#implementation","title":"Implementation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\ntypedef long long ll;\nusing namespace std;\n\nvector&lt;ll&gt; fibo = {1, 2};\n\nstring zeckendorf(ll n)\n{\n\n   while(fibo.back() &lt; n){\n      fibo.push_back(fibo[fibo.size()-1] + fibo[fibo.size()-2]);\n   }\n\n   ll p = fibo.size() - 1;\n   while(fibo[p] &gt; n) p--;\n   string res = \"\";\n   while(p &gt;= 0){\n      if(fibo[p] &lt;= n){\n         res += \"1\";\n         n -= fibo[p];\n      }else{\n         res += \"0\";\n      }\n      p--;\n   }\n\n   return res;\n}\n\nsigned main()\n{\n   ios::sync_with_stdio(false);\n   cin.tie(0);\n   ll q;\n   cin &gt;&gt; q;\n   while (q--)\n   {\n      ll n;\n      cin &gt;&gt; n;\n      cout &lt;&lt; zeckendorf(n) &lt;&lt; '\\n';\n   }\n}\n</code></pre>"},{"location":"editorials/Implementation%20Gauntlets/chaos/","title":"1.The Trial of Order and Chaos","text":""},{"location":"editorials/Implementation%20Gauntlets/chaos/#problem-statement","title":"Problem Statement","text":"<ul> <li>English</li> <li>French</li> <li>Arabic</li> </ul>"},{"location":"editorials/Implementation%20Gauntlets/chaos/#solution","title":"Solution","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\ntypedef long long ll;\ntypedef __int128 int128;\n\nint main() {\n    int n, m; \n    cin &gt;&gt; n &gt;&gt; m;\n\n    vector&lt;ll&gt; a(n);\n    for (int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i];\n\n    // --- Ritual 1 ---\n    vector&lt;int&gt; pre(n), alt_pre(n);\n    for (int i = 0; i &lt; n; ++i) {\n        ll curr = 0;\n        if (i % 2 == 0) for (int j = 0; j &lt;= i; j++) curr += a[j];\n        else {\n            int sign = 1;\n            for (int j = i; j &gt;= 0; --j) {\n                curr += sign * a[j];\n                sign *= -1;\n            }\n        }\n        if (i % 2) alt_pre[i] = ((curr % m) + m) % m;\n        else pre[i] = curr % m;\n    }\n\n    for (int i = 0; i &lt; n; ++i) {\n        if (i % 2) a[i] = alt_pre[i];\n        else a[i] = pre[i];\n        cout &lt;&lt; a[i] &lt;&lt; \" \";\n    }\n    cout &lt;&lt; \"\\n\";\n\n    // --- Ritual 2 ---\n    vector&lt;ll&gt; b;\n    for (int i = 0; i &lt; n - 2; ++i) {\n        for (int j = i + 1; j &lt; n - 1; ++j) {\n            for (int k = j + 1; k &lt; n; ++k) {\n                ll val = (a[i] + a[j] + a[k]) % m;\n                if (val % 2 == 0) b.push_back(val);\n                else {\n                    int128 sq = 1LL * val * val;\n                    sq %= m;\n                    b.push_back((ll)sq);\n                }\n            }\n        }\n    }\n\n    for (ll x: b) cout &lt;&lt; x &lt;&lt; \" \";\n    cout &lt;&lt; \"\\n\";\n\n    // --- Ritual 3 ---\n    sort(b.begin(), b.end());\n    for (int i = 0; i * 3 &lt; (int)b.size(); i++) {\n        if (i % 2 == 1) reverse(b.begin() + i * 3, b.begin() + min((int)b.size(), i * 3 + 3));\n    }\n\n    for (ll x: b) cout &lt;&lt; x &lt;&lt; \" \";\n    cout &lt;&lt; \"\\n\";\n\n    // --- Ritual 4 ---\n    sort(b.begin(), b.end());\n    b.erase(unique(b.begin(), b.end()), b.end());\n\n    vector&lt;ll&gt; add;\n    set&lt;ll&gt; B(b.begin(), b.end());\n    for (int t = 0; t &lt; m; t++) {\n        if (B.count(t) == 0 &amp;&amp; B.count(t + 1) == 1) add.push_back(t);\n    }\n    for (ll x: add) b.push_back(x);\n\n    sort(b.begin(), b.end());\n    b.erase(unique(b.begin(), b.end()), b.end());\n\n    for (ll x: b) cout &lt;&lt; x &lt;&lt; \" \";\n    cout &lt;&lt; \"\\n\";\n\n    // --- Ritual 5 ---\n    vector&lt;ll&gt; c;\n    for (ll x: b) {\n        if (x % 3 == 0) c.push_back((x / 3) % m);\n        else if (x % 3 == 1) c.push_back((x * 2 + 1) % m);\n        else c.push_back(((x * x - 1) % m + m) % m);\n    }\n\n    for (ll x: c) if (x % 2 == 0) cout &lt;&lt; x &lt;&lt; \" \";\n    for (ll x: c) if (x % 2 == 1) cout &lt;&lt; x &lt;&lt; \" \";\n    cout &lt;&lt; \"\\n\";\n\n\n    return 0;\n}\n</code></pre>"},{"location":"editorials/NAOI%20TST%202025/","title":"NAOI TST 2025 Editorials","text":"<p>This directory contains editorials for the problems from the NAOI TST 2025 contest. This contest served as a selection test to select Algeria's team in the North African Olympiad in Informatics (NAOI) 2025.</p>"},{"location":"editorials/NAOI%20TST%202025/#problems","title":"Problems","text":"<ul> <li>Jump</li> <li>Sequence</li> <li>Rectangles</li> <li>DNA</li> <li>KOI</li> <li>Clocks</li> <li>Pi</li> <li>Switch</li> </ul>"},{"location":"editorials/NAOI%20TST%202025/clocks/","title":"Clocks","text":"<p>Written by Omar Abdelkafi Ykrelef.</p>"},{"location":"editorials/NAOI%20TST%202025/clocks/#problem-statement","title":"Problem Statement","text":"<ul> <li>English</li> <li>Arabic</li> </ul>"},{"location":"editorials/NAOI%20TST%202025/clocks/#solution","title":"Solution","text":"<p>We have 9 clocks arranged in a \\(3 \\times 3\\) grid, and we are given 9 numbers in a \\(3 \\times 3\\) array. Each number describes the current time expression of the corresponding clock:</p> <ul> <li>\\(0 \\rightarrow\\) O\u2019clock (12:00)</li> <li>\\(1 \\rightarrow\\) Quarter past (3:00)</li> <li>\\(2 \\rightarrow\\) Half past (6:00)</li> <li>\\(3 \\rightarrow\\) Quarter to (9:00)</li> </ul> <p>So each clock is like a counter modulo 4.</p>"},{"location":"editorials/NAOI%20TST%202025/clocks/#moves","title":"Moves","text":"<p>There are 9 possible moves. Each move rotates a certain subset of clocks to the next expression (i.e., rotates them \\(90^\\circ\\) clockwise).</p> <p>This means it adds \\(+1 \\pmod{4}\\) to the values of those clocks. We are allowed to apply each move multiple times.</p>"},{"location":"editorials/NAOI%20TST%202025/clocks/#goal","title":"Goal","text":"<p>Our goal is to apply moves so that all clocks show 12:00 (0), while minimizing the number of moves used.</p>"},{"location":"editorials/NAOI%20TST%202025/clocks/#key-observations","title":"Key Observations","text":"<ul> <li> <p>We will have to use a move at most 3 times, because applying a move 4 times returns the affected clocks back to their original state.</p> </li> <li> <p>We can apply the moves in any order, since the order does not matter (they just add values modulo 4).</p> </li> </ul>"},{"location":"editorials/NAOI%20TST%202025/clocks/#approach","title":"Approach","text":"<p>We can represent the solution using an array of size 9 (the number of moves). Each entry in this array stores the number of times we use that move.</p> <p>Since each move can be used at most 3 times, there are 4 possibilities for each move (\\(0, 1, 2, 3\\)).</p> <p>So in total, we need to check:</p> \\[ 4^9 = 262{,}144 \\] <p>possible answers.</p>"},{"location":"editorials/NAOI%20TST%202025/clocks/#idea-base-4-counter","title":"Idea: Base-4 Counter","text":"<p>We can generate all possibilities using a base-4 counter:</p> <ul> <li>Start with \\([0,0,0,0,0,0,0,0,0]\\).</li> <li>Add \\(+1\\) to the first index.</li> <li>If it becomes 4, reset it to 0 and carry over to the next index.</li> <li>Repeat this process to generate all \\(4^9\\) possibilities.</li> </ul> <p>For each generated sequence, we apply the moves to the initial state of the clocks and check:</p> <ul> <li>Do all clocks become 0?</li> <li>If yes, count the total number of moves used.</li> <li>Keep track of the sequence with the least total moves.</li> </ul>"},{"location":"editorials/NAOI%20TST%202025/clocks/#complexity-analysis","title":"Complexity Analysis","text":"\\[ \\text{Total time complexity } = O(4^9) \\]"},{"location":"editorials/NAOI%20TST%202025/clocks/#implementation","title":"Implementation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// Move 1\nvoid move0(vector&lt;vector&lt;int&gt;&gt;&amp; a){\n    a[0][0] = (a[0][0] + 1) % 4;\n    a[0][1] = (a[0][1] + 1) % 4;\n    a[1][0] = (a[1][0] + 1) % 4;\n    a[1][1] = (a[1][1] + 1) % 4;\n}\n\n// Move 2\nvoid move1(vector&lt;vector&lt;int&gt;&gt;&amp; a){\n    a[0][0] = (a[0][0] + 1) % 4;\n    a[0][1] = (a[0][1] + 1) % 4;\n    a[0][2] = (a[0][2] + 1) % 4;\n}\n\n// Move 3\nvoid move2(vector&lt;vector&lt;int&gt;&gt;&amp; a){\n    a[0][1] = (a[0][1] + 1) % 4;\n    a[0][2] = (a[0][2] + 1) % 4;\n    a[1][1] = (a[1][1] + 1) % 4;\n    a[1][2] = (a[1][2] + 1) % 4;\n}\n\n// Move 4\nvoid move3(vector&lt;vector&lt;int&gt;&gt;&amp; a){\n    a[0][0] = (a[0][0] + 1) % 4;\n    a[1][0] = (a[1][0] + 1) % 4;\n    a[2][0] = (a[2][0] + 1) % 4;\n}\n\n// Move 5\nvoid move4(vector&lt;vector&lt;int&gt;&gt;&amp; a){\n    a[0][1] = (a[0][1] + 1) % 4;\n    a[1][0] = (a[1][0] + 1) % 4;\n    a[1][1] = (a[1][1] + 1) % 4;\n    a[1][2] = (a[1][2] + 1) % 4;\n    a[2][1] = (a[2][1] + 1) % 4;\n}\n\n// Move 6\nvoid move5(vector&lt;vector&lt;int&gt;&gt;&amp; a){\n    a[0][2] = (a[0][2] + 1) % 4;\n    a[1][2] = (a[1][2] + 1) % 4;\n    a[2][2] = (a[2][2] + 1) % 4;\n}\n\n// Move 7\nvoid move6(vector&lt;vector&lt;int&gt;&gt;&amp; a){\n    a[1][0] = (a[1][0] + 1) % 4;\n    a[1][1] = (a[1][1] + 1) % 4;\n    a[2][0] = (a[2][0] + 1) % 4;\n    a[2][1] = (a[2][1] + 1) % 4;\n}\n\n// Move 8\nvoid move7(vector&lt;vector&lt;int&gt;&gt;&amp; a){\n    a[2][0] = (a[2][0] + 1) % 4;\n    a[2][1] = (a[2][1] + 1) % 4;\n    a[2][2] = (a[2][2] + 1) % 4;\n}\n\n// Move 9\nvoid move8(vector&lt;vector&lt;int&gt;&gt;&amp; a){\n    a[1][1] = (a[1][1] + 1) % 4;\n    a[1][2] = (a[1][2] + 1) % 4;\n    a[2][1] = (a[2][1] + 1) % 4;\n    a[2][2] = (a[2][2] + 1) % 4;\n}\n\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; clocks(3, vector&lt;int&gt;(3));\n\n    // Input initial clock states\n    for (int i = 0; i &lt; 3; i++)\n        for (int j = 0; j &lt; 3; j++)\n            cin &gt;&gt; clocks[i][j];\n\n    int res = INT_MAX;          // minimum number of moves\n    vector&lt;int&gt; ans(9);         // best move sequence\n    vector&lt;int&gt; counter(10, 0); // base-4 counter (size 10 to simplify carry)\n\n    // Target (all clocks at 0)\n    vector&lt;vector&lt;int&gt;&gt; target(3, vector&lt;int&gt;(3, 0));\n\n    while (counter[9] &lt; 1) {\n        // Copy the initial grid\n        vector&lt;vector&lt;int&gt;&gt; cur = clocks;\n\n        // Apply moves according to counter[]\n        for (int i = 0; i &lt; 9; i++) {\n            for (int j = 0; j &lt; counter[i]; j++) {\n                if (i == 0) move0(cur);\n                if (i == 1) move1(cur);\n                if (i == 2) move2(cur);\n                if (i == 3) move3(cur);\n                if (i == 4) move4(cur);\n                if (i == 5) move5(cur);\n                if (i == 6) move6(cur);\n                if (i == 7) move7(cur);\n                if (i == 8) move8(cur);\n            }\n        }\n\n        // Check if solved\n        if (cur == target) {\n            int cres = 0;\n            for (int i : counter) cres += i;\n\n            if (cres &lt; res) {\n                res = cres;\n                ans = counter;\n            }\n        }\n\n        // Increment base-4 counter\n        int i = 0;\n        counter[i]++;\n        while (counter[i] == 4) {\n            counter[i] = 0;\n            i++;\n            counter[i]++;\n        }\n    }\n\n    // Print answer (moves used)\n    for (int i = 0; i &lt; 9; i++) {\n        while (ans[i] &gt; 0) {\n            ans[i]--;\n            cout &lt;&lt; i + 1 &lt;&lt; \" \";\n        }\n    }\n    cout &lt;&lt; \"\\n\";\n}\n</code></pre>"},{"location":"editorials/NAOI%20TST%202025/dna/","title":"DNA","text":"<p>Written by Kimouche Taki</p>"},{"location":"editorials/NAOI%20TST%202025/dna/#problem-statement","title":"Problem statement :","text":"<ul> <li>English</li> <li>Arabic</li> </ul>"},{"location":"editorials/NAOI%20TST%202025/dna/#solution","title":"Solution :","text":""},{"location":"editorials/NAOI%20TST%202025/dna/#subtask-i-1-leq-n-leq-100quad-r-leq-10","title":"Subtask I:  \\(1 \\leq N \\leq 100,\\quad R \\leq 10\\)","text":"<ul> <li>For this we loop over all substrings of the given string at cost of \\(O(N^2)\\) time (aka \\(\\binom{N}{2}\\)), and for each substring we check whether we satisfy the requirements in \\(O(N \\cdot R)\\) time. Then we keep the minimum length. (We must handle the impossibility condition too.)</li> </ul> <p>Time complexity: \\(O(N^3 \\cdot R)\\) \u2014 too slow for larger input sizes \ud83d\ude10 Space complexity: \\(O(1)\\) extra space aside from the input string.</p>"},{"location":"editorials/NAOI%20TST%202025/dna/#subtask-ii-1-leq-n-leq-4000quad-r-leq-10","title":"Subtask II: \\(1 \\leq N \\leq 4000,\\quad R \\leq 10\\)","text":"<p>To speed things up, we use prefix sums of each required character's occurrences to query in \\(O(1)\\) the frequency of each character \\(x\\) in our set of required characters.</p> <p>To implement this, we create a <code>map &lt;int, vector &lt;int&gt;&gt; mp</code> where <code>mp[x]</code> is the prefix sum vector of the occurrences of character <code>x</code>.</p> <p>Time complexity: - Looping over all substrings: \\(O(N^2)\\) - Checking all characters: \\(O(R \\log R)\\) - Building prefix sums: \\(O(NR)\\) - Total: \\(O(N^2 R \\log R)\\)</p> <p>Space complexity: \\(O(NR)\\) extra space due to prefix sum build. (You can mitigate the log factor by using <code>unordered_map</code> with a good hash function.)</p> <p>Still slow though... \ud83d\ude05</p>"},{"location":"editorials/NAOI%20TST%202025/dna/#subtask-iv-1-leq-n-leq-200000","title":"Subtask IV: \\(1 \\leq N \\leq 200{,}000\\)","text":"<p>To solve this final subtask (and thus the entire problem), we use a greedy strategy: the two-pointer technique (aka sliding window).</p> <p>The goal is to catch a segment of minimal length that satisfies all \\(R\\) requirements.</p> <p>We initialize two pointers <code>l, r = 0</code> and a frequency map/array. We expand the window by incrementing the frequency of <code>array[r]</code>.</p> <p>Instead of prefix sums, we use a <code>satisfied</code> variable that only increments when a condition from the \\(R\\) requirements is fulfilled. This avoids the \\(O(NR)\\) factor and gives a major optimization.</p> <p>Whenever <code>satisfied == R</code>, we try to shrink the window from the left (<code>l</code>) while maintaining the condition, and we always track the minimum segment length.</p> <p>Time complexity: \\(O(N)\\) \u2014 both <code>l</code> and <code>r</code> move at most \\(N\\) times. Space complexity: \\(O(\\)# distinct characters\\()\\)</p> <p>We are finally done........</p>"},{"location":"editorials/NAOI%20TST%202025/dna/#implementation","title":"Implementation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\ntypedef long long ll;\n\n#define pb push_back\n#define sz(x) (int) x.size()\n\n// hopeful\nint main(){\n\n    ios::sync_with_stdio(NULL); cin.tie(0);\n\n    int n , r , k; cin &gt;&gt; n &gt;&gt; k &gt;&gt; r;\n    vector &lt;int&gt; vec(n); \n    for (int i = 0 ; i &lt; n ; ++i){\n        cin &gt;&gt; vec[i];\n    }\n    unordered_map &lt;int , int&gt; quant;\n    for (int i = 0 ; i &lt; r ; ++i){\n        int c , q; cin &gt;&gt; c &gt;&gt; q;\n        quant[c] = q;\n    }\n\n    int L = 0 , R = 0 , satis = 0 , mn = INT_MAX;\n    unordered_map &lt;int , int&gt; freq;\n\n    while (L &lt;= R &amp;&amp; R &lt; n &amp;&amp; L &lt; n){\n\n        ++freq[vec[R]];\n        if (quant.count(vec[R]) &amp;&amp; freq[vec[R]] == quant[vec[R]]) ++satis;\n\n\n        while (satis == r){\n            mn = min(mn , R - L + 1);\n\n            int basis = vec[L];\n            --freq[basis];\n            if (freq[basis] &lt; quant[basis] &amp;&amp; quant.count(basis)) satis--;\n            if (!freq[basis]) freq.erase(basis);\n\n            ++L;           \n        }\n\n        ++R;\n    }\n\n\n    if (mn == INT_MAX || !mn) {\n        cout &lt;&lt; \"impossible\" &lt;&lt; \"\\n\";\n        return 0;\n    }\n\n    cout &lt;&lt; mn &lt;&lt; \"\\n\";\n\n    return 0;\n}\n</code></pre> <p>Hope you learnt something along the way :)</p>"},{"location":"editorials/NAOI%20TST%202025/jump/","title":"Jump","text":"<p>Written by Omar Abdelkafi Ykrelef.</p>"},{"location":"editorials/NAOI%20TST%202025/jump/#problem-statement","title":"Problem Statement","text":"<ul> <li>English</li> <li>Arabic</li> </ul>"},{"location":"editorials/NAOI%20TST%202025/jump/#solution","title":"Solution","text":"<p>We are given an \\(n \\times n\\) grid where each cell contains a number between 0\u20139. This number determines how many cells we can move either to the right or downward.</p> <ul> <li>If the number is 0, the cell is a dead end.</li> <li>The goal is to count the number of ways to move from the upper-left corner \\((0,0)\\) to the lower-right corner \\((n-1,n-1)\\).</li> </ul>"},{"location":"editorials/NAOI%20TST%202025/jump/#70-points-approach","title":"70 Points Approach","text":"<p>To solve 70% of the problem, we can use dynamic programming.</p> <p>Define a 2D array:</p> \\[ dp[i][j] = \\text{number of ways to reach cell } (i,j) \\text{ from } (0,0). \\] <ul> <li>Initialize all cells with \\(0\\), except:</li> </ul> \\[ dp[0][0] = 1 \\] <ul> <li>For each cell \\((i,j)\\), let:</li> </ul> \\[ k = a[i][j] \\] <ul> <li> <p>If \\(k \\neq 0\\):</p> </li> <li> <p>Add \\(dp[i][j]\\) to \\(dp[i+k][j]\\) (moving down)</p> </li> <li>Add \\(dp[i][j]\\) to \\(dp[i][j+k]\\) (moving right)</li> <li>But only if those positions are inside the grid.</li> </ul> <p>At the end:</p> \\[ \\text{Answer} = dp[n-1][n-1] \\]"},{"location":"editorials/NAOI%20TST%202025/jump/#100-points-approach","title":"100 Points Approach","text":"<p>For the full score, we need to handle very large numbers that cannot fit in standard integer types.</p> <ul> <li>Instead of integers, store strings in the DP table.</li> <li>Initialize all cells with <code>\"0\"</code>, except:</li> </ul> \\[ dp[0][0] = \"1\" \\] <ul> <li>Write a string addition function to add big integers.</li> </ul>"},{"location":"editorials/NAOI%20TST%202025/jump/#implementing-string-addition","title":"Implementing String Addition","text":"<p>The idea is the same as manual addition:</p> <ol> <li>Start from the last digit of both strings.</li> <li>Add them together.</li> <li>If the sum is greater than 9, carry 1 to the next digit.</li> <li>Continue until all digits are processed.</li> </ol> <p>This way, we can correctly handle very large values of \\(dp[i][j]\\).</p>"},{"location":"editorials/NAOI%20TST%202025/jump/#implementation","title":"Implementation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint n;\n\n// Function to add two big integers stored as reversed strings\n// (digits are stored least significant first, e.g. \"123\" means 321)\nstring add(string a, string b) {\n    string res(150, '0'); // result buffer initialized with '0'\n\n    // copy digits of a into res\n    for (int i = 0; i &lt; a.size(); i++) {\n        res[i] = a[i];\n    }\n\n    // add digits of b into res\n    for (int i = 0; i &lt; b.size(); i++) {\n        char to = res[i] + (b[i] - '0'); // add corresponding digits\n        int j = 1;\n        // handle carry if sum &gt; '9'\n        while (to &gt; '9') {\n            res[i + j - 1] = (to % '9') + ('0' - 1); // set current digit\n            to = res[i + j] + 1; // carry to next digit\n            j++;\n        }\n        res[i + j - 1] = to; // store final digit\n    }\n    return res;\n}\n\n// Check if coordinates (i, j) are inside the n x n grid\nbool in(int i, int j) {\n    return (i &lt; n &amp;&amp; i &gt;= 0 &amp;&amp; j &lt; n &amp;&amp; j &gt;= 0);\n}\n\nint main() {\n    cin &gt;&gt; n;\n\n    // input grid (each cell contains number of steps to move)\n    vector&lt;vector&lt;int&gt;&gt; a(n, vector&lt;int&gt;(n));\n\n    // dp[i][j] = number of ways to reach (i, j), stored as string\n    vector&lt;vector&lt;string&gt;&gt; dp(n, vector&lt;string&gt;(n, \"0\"));\n    dp[0][0] = \"1\"; // start position has exactly 1 way\n\n    // read input grid\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            cin &gt;&gt; a[i][j];\n        }\n    }\n\n    // fill DP table\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            int k = a[i][j]; // step size from (i, j)\n            if (k == 0) continue; // dead cell, skip\n\n            // move right\n            if (in(i, j + k)) {\n                int J = j + k;\n                dp[i][J] = add(dp[i][j], dp[i][J]);\n            }\n\n            // move down\n            if (in(i + k, j)) {\n                int I = i + k;\n                dp[I][j] = add(dp[i][j], dp[I][j]);\n            }\n        }\n    }\n\n    // final result = ways to reach bottom-right cell\n    string res = dp[n - 1][n - 1];\n\n    // reverse string back to normal order\n    reverse(res.begin(), res.end());\n\n    // print result without leading zeros\n    bool ok = false;\n    for (int i = 0; i &lt; res.size(); i++) {\n        if (res[i] != '0') ok = true;\n        if (ok) cout &lt;&lt; res[i];\n    }\n    if (!ok) cout &lt;&lt; 0;\n}\n</code></pre>"},{"location":"editorials/NAOI%20TST%202025/koi/","title":"KOI","text":"<p>Written by Haithem Djefel.</p>"},{"location":"editorials/NAOI%20TST%202025/koi/#problem-statement","title":"Problem Statement:","text":"<ul> <li>English</li> <li>Arabic</li> </ul>"},{"location":"editorials/NAOI%20TST%202025/koi/#solution","title":"Solution","text":"<p>We can use the following approach, for each task, calculate its value (i.e. the number of points assigned to it), we can initialize all problems with value n, and decrease it by 1 for each contestant who solved the task. </p> <p>then for each contestant calculate the score he/she got, after that we can sort the list of contestants and get the index of Kheira and the we\u2019re done.</p> <p>total time complexity: \\(O(N \\times T)\\).</p>"},{"location":"editorials/NAOI%20TST%202025/koi/#implementation","title":"Implementation:","text":"<pre><code>// Problem solution by Haithem Djefel\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair&lt;ll, ll&gt; pll;\n\nconst int MOD = 1000000007;\nconst ll LOG = 31;\n\n#define db(x) cerr &lt;&lt; #x &lt;&lt; \" = \" &lt;&lt; x &lt;&lt; \" | \"\n#define dbg(x) cerr &lt;&lt; #x &lt;&lt; \" = \" &lt;&lt; x &lt;&lt; \"\\n\"\n\n#define Algerian ios::sync_with_stdio(0);\n#define OI cin.tie(NULL);\n\n#define f first\n#define s second\n\nint main() {\n    Algerian OI\n\n    ll n, t, p;\n    cin &gt;&gt; n &gt;&gt; t &gt;&gt; p;\n\n    vector&lt;vector&lt;ll&gt;&gt; contestant(n);\n\n    // initialize all tasks with value n\n    vector&lt;ll&gt; tasks(t, n);\n\n    for (ll i = 0; i &lt; n; i++) {\n        for (ll j = 0; j &lt; t; j++) {\n            ll c;\n            cin &gt;&gt; c;\n\n            if (c) {\n                contestant[i].push_back(j);\n                tasks[j]--;\n            }\n        }\n    }\n\n    vector&lt;pair&lt;pll, ll&gt;&gt; scores(n);\n\n    for (ll i = 0; i &lt; n; i++) {\n        ll cur = 0;\n\n        for (auto x : contestant[i]) cur += tasks[x];\n        scores[i] = {{cur, contestant[i].size()}, i};\n    }\n    --p;\n\n    // custom comparator to sort contestants acoording to the problem description\n    auto cmp = [=](pair&lt;pll, ll&gt; a, pair&lt;pll, ll&gt; b) -&gt; bool {\n        if (a.f.f != b.f.f) return a.f.f &gt; b.f.f;\n        else if (a.f.s != b.f.s) return a.f.s &gt; b.f.s;\n        else return a.s &lt; b.s;\n    };\n\n    sort(scores.begin(), scores.end(), cmp);\n\n    ll idx, score;\n\n    for (ll i = 0; i &lt; n; i++) {\n        if (scores[i].s == p) {\n            idx = i;\n            score = scores[i].f.f;\n        }\n    }\n\n    // add 1 because our resault is 0-indexed\n    cout &lt;&lt; score &lt;&lt; \" \" &lt;&lt; idx + 1 &lt;&lt; \"\\n\";\n\n    return 0;\n}\n</code></pre>"},{"location":"editorials/NAOI%20TST%202025/pi/","title":"Pi","text":"<p>Written by Iyed Baassou</p>"},{"location":"editorials/NAOI%20TST%202025/pi/#problem-statement","title":"Problem Statement","text":"<ul> <li>English</li> <li>Arabic</li> </ul>"},{"location":"editorials/NAOI%20TST%202025/pi/#observations","title":"Observations:","text":"<ul> <li>The problem asks for the number of non-decreasing arrays of size \\(k\\) that sums up to \\(n\\).</li> <li>The low constraint for \\(n\\) (\\(1 \\le n \\le 250\\)) hints heavily to a 3-states DP.</li> </ul>"},{"location":"editorials/NAOI%20TST%202025/pi/#part-i-recursion","title":"Part I: Recursion","text":"<p>This problem can be solved using recursion, since we, at each point, try different values that keep getting a sum of \\(n\\) possible and keep the array non-decreasing.</p> <p>This can be done by recursing through all indices \\(i\\) (\\(0 &lt;= i &lt; k\\)) while tracking <code>sum so far</code> and <code>minimum possible value</code>.</p> <p>Let's denote our recursive function as <code>pi(i, sum, mn)</code>.</p> <p>Notice that we also need a way to make sure the array is still both non-decreasing and that we can continue from the current value to a non-decreasing array.</p> <p>Notice that in the example \\(n = 8\\) and \\(k=4\\), is it not possible to use the value 3 at the first index. Because this forces us to use values greater or equal to 3 in the 3 remaining indices to get a sum of 8... Which is impossible because \\(3 \\times 4 = 12 \\ge 8\\), while the value 2 allows us to use values greater or equal to 2 in the remaining 3 indices to get a sum of 8 because \\(2 \\times 4 = 8 \\le 8\\)</p> <p>Thus we can conclude the following condition: \\(a_i \\le \\frac{(n - sum)}{(k - i - 1)}\\).</p> <p>This can be done to all indices and makes sure our final array is valid.</p> <p>Let's now move to implementation, we will, for each value \\(j\\) in \\([mn, \\frac{(n - sum)}{(k - i - 1)}]\\), recurse to <code>pi(i + 1, sum + j, max(mn, j))</code>.</p> <p>Once we reach \\(i = k - 1\\) we increase the result if <code>sum</code> is equal to \\(n\\).</p>"},{"location":"editorials/NAOI%20TST%202025/pi/#code","title":"Code:","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint n, k;\n\nint ways = 0;\n\nvoid pi(int i, int sum, int mn) {\n    if (i == k - 1) {\n        if (sum == n) ways++;\n        return;\n    }\n\n    for (int j = prev; j &lt;= (n - sum) / (k - i - 1); ++j) {\n        pi(i + 1, sum + j, max(mn, j));\n    }\n}\n\nint main() {\n    cin &gt;&gt; n &gt;&gt; k;\n\n    for (int j = 1; j &lt;= n / k; ++j) {\n        pi(0, j, j);\n    }\n\n    cout &lt;&lt; ways &lt;&lt; \"\\n\";\n\n    return 0;\n}\n</code></pre>"},{"location":"editorials/NAOI%20TST%202025/pi/#time-complexity","title":"Time complexity:","text":"<p>In worstcase, the depth of the recursion is k. Each depth tries approximately \\(n\\) values.</p> <p>Which causes a time complexity of \\(O(n^k)\\) which is huge but the number of tries is very optimized in our approach which causes it to pass subtask 1 and subtask 2. (Considering weak testcases)</p> <p>But this is not enough, we want a full solution, that beautiful green text or box. \u2705</p>"},{"location":"editorials/NAOI%20TST%202025/pi/#part-ii-dp-memoization","title":"Part II: DP Memoization","text":"<p>So the sole problem about recursion is recomputing values over and over again. Memoization is the best solution to this issue.</p> <p>We'll simply only memoize the result for each recursion call <code>pi(i, sum, mn)</code> using a 3D DP table, and return it directly when recursion tries to recompute it.</p>"},{"location":"editorials/NAOI%20TST%202025/pi/#code_1","title":"Code:","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint n, k;\n\nint ways = 0;\n\nint dp[250][250][250];\n\nint pi(int i, int sum, int prev) {\n    if (i == k - 1) {\n        return dp[i][sum][prev] = (sum == n);\n    }\n\n    if (dp[i][sum][prev] != -1) return dp[i][sum][prev];\n\n    int curr = 0;\n    for (int j = prev; j &lt;= (n - sum) / (k - i - 1); ++j) {\n        curr += pi(i + 1, sum + j, max(prev, j));\n    }\n\n    return dp[i][sum][prev] = curr;\n}\n\nint main() {\n    cin &gt;&gt; n &gt;&gt; k;\n\n    memset(dp, -1, sizeof(dp));\n\n    for (int j = 1; j &lt;= n / k; ++j) {\n        ways += pi(0, j, j);\n    }\n\n    cout &lt;&lt; ways &lt;&lt; \"\\n\";\n\n    return 0;\n}\n</code></pre>"},{"location":"editorials/NAOI%20TST%202025/pi/#time-complexity_1","title":"Time complexity:","text":"<p>Since the dynamic programming memoization handles the recomputations, the time complexity lowers down to both space and time complexities of \\(O(n^2\\cdot k)\\)</p>"},{"location":"editorials/NAOI%20TST%202025/rectangles/","title":"Rectangles","text":"<p>Written by Raouf Ould Ali.</p>"},{"location":"editorials/NAOI%20TST%202025/rectangles/#problem-statement","title":"Problem Statement","text":"<ul> <li>English</li> <li>Arabic</li> </ul>"},{"location":"editorials/NAOI%20TST%202025/rectangles/#solution","title":"Solution","text":"<p>We are given <code>N</code> axis-aligned rectangles inside the box <code>[0..xmax] \u00d7 [0..ymax]</code>. We want to choose a point B on the top (<code>(x,ymax)</code>) or right (<code>(xmax,y)</code>) border, so that the segment from (0,0) to B crosses the maximum number of rectangles.</p>"},{"location":"editorials/NAOI%20TST%202025/rectangles/#1-key-observation","title":"1. Key observation","text":"<ul> <li>Each rectangle corresponds to an interval of slopes for which the ray from <code>(0,0)</code> intersects it.</li> <li>Example: If the ray goes through <code>(x,y)</code>, then its slope is <code>y/x</code>. For a rectangle <code>(a,b,c,d)</code>, the ray hits it if the slope is between the slopes of corners <code>(a,d)</code> and <code>(c,b)</code>.</li> </ul> <p>Thus, the problem reduces to: \ud83d\udc49 Find the slope with the maximum number of covering intervals.</p>"},{"location":"editorials/NAOI%20TST%202025/rectangles/#2-from-slopes-to-boundary-points","title":"2. From slopes to boundary points","text":"<p>Instead of working with fractions <code>y/x</code>, we can map every slope to a unique boundary point B:</p> <ul> <li>If the slope hits the top border first, that\u2019s some <code>(X,ymax)</code>.</li> <li>If it hits the right border first, that\u2019s some <code>(xmax,Y)</code>.</li> </ul> <p>This way, every slope corresponds to exactly one candidate point <code>B</code>.</p>"},{"location":"editorials/NAOI%20TST%202025/rectangles/#3-sweeping","title":"3. Sweeping","text":"<p>For each rectangle:</p> <ul> <li>Compute the entry point (when the ray starts intersecting it).</li> <li>Compute the exit point (when the ray stops intersecting it).</li> <li>Add a <code>+1</code> event at the entry point, and a <code>-1</code> event at the exit point.</li> </ul> <p>Now we sort all events in increasing slope order. While sweeping through them, we keep a running counter of active rectangles. The maximum of this counter is the answer.</p>"},{"location":"editorials/NAOI%20TST%202025/rectangles/#4-implementation-tricks","title":"4. Implementation tricks","text":"<ul> <li> <p>To avoid floating-point errors, we work entirely in integers:</p> </li> <li> <p>Using formulas like <code>(a*ymax + d - 1)/d</code> for ceiling division.</p> </li> <li>Distinguishing between hitting the top or right border depending on whether the projected x-coordinate \u2264 <code>xmax</code>.</li> <li>A custom comparator orders border points in the same order as increasing slopes.</li> <li>Multiple valid answers may exist; output any.</li> </ul>"},{"location":"editorials/NAOI%20TST%202025/rectangles/#5-complexity","title":"5. Complexity","text":"<ul> <li>Each rectangle contributes 2 events \u2192 <code>O(N)</code> events.</li> <li>Sorting events: <code>O(N log N)</code>.</li> <li>Sweeping: <code>O(N)</code>.</li> </ul> <p>Total complexity: <code>O(N log N)</code>, efficient for <code>N \u2264 10^4</code>.</p>"},{"location":"editorials/NAOI%20TST%202025/rectangles/#implementation","title":"Implementation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\n\nstruct cmp {\n    bool operator()(const pair&lt;ll, ll&gt; &amp;a, const pair&lt;ll, ll&gt; &amp;b) const {\n        if (a.second != b.second)\n            return a.second &gt; b.second;\n        return a.first &lt; b.first;\n    }\n};\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll xmax, ymax, n;\n    cin &gt;&gt; xmax &gt;&gt; ymax &gt;&gt; n;\n\n    map&lt;pair&lt;ll, ll&gt;, ll, cmp&gt; hi;\n\n    for (ll i = 0; i &lt; n; i++) {\n        ll a, b, c, d;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;\n        // begin : a,d\n        // end : c,b\n        if (a == 0) {\n            hi[{0, ymax}]++;\n        } else if ((a * ymax + d - 1) / d &lt;= xmax) {\n            hi[{(a * ymax + d - 1) / d, ymax}]++;\n        } else {\n            hi[{xmax, (d * xmax) / a}]++;\n        }\n\n        if (b == 0) {\n            hi[{xmax, -1}]--;\n        } else if ((c * ymax + b - 1) / b &lt;= xmax) {\n            hi[{(c * ymax + b) / b, ymax}]--;\n        } else {\n            hi[{xmax, (b * xmax - 1) / c}]--;\n        }\n    }\n\n    pair&lt;ll, ll&gt; maxipair = {0, 0};\n    ll maxi = -1;\n\n    ll current = 0;\n    for (auto c : hi) {\n        current += c.second;\n        if (current &gt; maxi) {\n            maxi = current;\n            maxipair = c.first;\n        }\n    }\n\n    cout &lt;&lt; maxi &lt;&lt; ' ' &lt;&lt; maxipair.first &lt;&lt; ' ' &lt;&lt; maxipair.second &lt;&lt; '\\n';\n}\n</code></pre>"},{"location":"editorials/NAOI%20TST%202025/sequence/","title":"Sequence","text":""},{"location":"editorials/NAOI%20TST%202025/sequence/#problem-statement","title":"Problem Statement","text":"<ul> <li>English</li> <li>Arabic</li> </ul>"},{"location":"editorials/NAOI%20TST%202025/sequence/#solution","title":"Solution","text":"<p>We start with a sequence of numbers:</p> \\[ a_1, a_2, \\dots, a_n \\] <p>We can do the following operation:</p> <ul> <li>Pick two neighbors \\(a_i, a_{i+1}\\)</li> <li>Replace them with one number \\(\\max(a_i, a_{i+1})\\)</li> <li>Pay a cost of \\(\\max(a_i, a_{i+1})\\).</li> </ul> <p>After \\(n-1\\) operations, only one number remains. We want the minimum possible total cost.</p>"},{"location":"editorials/NAOI%20TST%202025/sequence/#the-answer","title":"The Answer","text":"<p>It turns out the answer is very simple:</p> \\[ \\text{Optimal Cost} = \\sum_{i=1}^{n-1} \\max(a_i, a_{i+1}) \\]"},{"location":"editorials/NAOI%20TST%202025/sequence/#why-this-works","title":"Why This Works","text":"<p>We need to explain two things:</p> <ol> <li>Why we can\u2019t do better than this sum (lower bound).</li> <li>Why we can actually achieve it (upper bound).</li> </ol>"},{"location":"editorials/NAOI%20TST%202025/sequence/#step-1-why-we-cant-do-better","title":"Step 1. Why we can\u2019t do better","text":"<p>Think about the boundaries between elements:</p> \\[ (a_1|a_2), (a_2|a_3), \\dots, (a_{n-1}|a_n) \\] <p>Each boundary \u201cdisappears\u201d when those two sides finally get merged.</p> <p>When \\(a_i\\) and \\(a_{i+1}\\) are merged for the first time, we must pay</p> \\[ \\max(a_i, a_{i+1}). \\] <p>This happens once per boundary, no matter what order we pick.</p> <p>\ud83d\udc49 That means the total cost is at least</p> \\[ \\sum_{i=1}^{n-1} \\max(a_i, a_{i+1}). \\]"},{"location":"editorials/NAOI%20TST%202025/sequence/#step-2-why-this-sum-is-achievable","title":"Step 2. Why this sum is achievable","text":"<p>Now we show we can actually reach this exact value.</p> <p>The trick: always merge the pair with the smallest possible max (a \"minimum reduce\").</p> <p>Why is this safe? Because:</p> <ul> <li>If you merge that pair, the neighbors on the left and right are at least as big, so the surrounding maxima don\u2019t change.</li> <li>The total \"sum of max\u2019s of neighbors\" decreases by exactly the cost you just paid.</li> </ul> <p>So after each merge:</p> \\[ \\text{New optimal cost sum} = \\text{Old sum} - \\text{cost of merge}. \\] <p>If you repeat this until one element is left, you\u2019ll have paid exactly the total sum of maxima from the beginning.</p>"},{"location":"editorials/NAOI%20TST%202025/sequence/#implementation","title":"Implementation","text":"<p>By Iyed Baassou.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\ntypedef long long ll;\n\nint main() {\n    int n; cin &gt;&gt; n;\n\n    vector&lt;int&gt; a(n);\n    for (int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i];\n\n    ll res = 0;\n\n    for (int i = 1; i &lt; n; ++i) {\n        res += max(a[i], a[i - 1]);\n    }\n\n    cout &lt;&lt; res &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"editorials/NAOI%20TST%202025/switch/","title":"Switch","text":"<p>Written by Fares Khelif.</p>"},{"location":"editorials/NAOI%20TST%202025/switch/#problem-statement","title":"Problem Statement","text":"<ul> <li>English</li> <li>Arabic</li> </ul>"},{"location":"editorials/NAOI%20TST%202025/switch/#solution","title":"Solution","text":""},{"location":"editorials/NAOI%20TST%202025/switch/#no-solution-case","title":"\"NO SOLUTION\" Case","text":"<ul> <li>We can notice that the electricity moves diagonally, so we can mark the points between squares as the points where the electricity settles.</li> <li>Consider a checkerboard: squares with <code>(i+j)</code> even are light, and <code>(i+j)</code> odd are dark.Since it is impossible to move from dark squares to light ones (or the opposite), any point with <code>(i+j)</code> odd is unreachable. As we start from <code>(0, 0)</code> where <code>(i+j)</code> is even, all odd-parity points are marked UNREACHABLE, as shown in the illustration :  </li> <li>So if ((n-1)+(m-1)) which simplifies to <code>(n+m)</code> is odd, then the answer would be \"NO SOLUTION\".</li> </ul>"},{"location":"editorials/NAOI%20TST%202025/switch/#find-the-solution-when-it-exists","title":"Find the solution when it exists","text":"<ol> <li>The cost to reach a point <code>[i, j]</code> is the minimum over all incoming diagonals: previous cost + 0 if the tile already aligns, or +1 if it must be turned.    So we can consider the whole circuit as a weighted graph, and the tiles as undirected edges, and the points between the squares as nodes. If the tile is ready to transfer the electricity from a point to another then the weight is 0, otherwise it's 1.</li> <li>We can implement Dijkstra's algorithm to find the shortest path from the source to the lamp.</li> </ol>"},{"location":"editorials/NAOI%20TST%202025/switch/#implementation","title":"Implementation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;  \nusing namespace std;  \n#define endl '\\n'  \nusing ll  = long long;  \nusing pll = pair&lt;ll, ll&gt;;  \n\n\nvoid solve() {  \n    ll n, m; cin &gt;&gt; n &gt;&gt; m;  \n    vector&lt;string&gt; a(n);  \n    for (ll i = 0; i &lt; n; i++) cin &gt;&gt; a[i];  \n    if ((n+m)%2==1) {  \n        cout &lt;&lt; \"NO SOLUTION\" &lt;&lt; endl;  \n        return;  \n    }  \n\n    vector&lt;vector&lt;vector&lt;pair&lt;ll, vector&lt;ll&gt;&gt;&gt;&gt;&gt; graph(n+1, vector&lt;vector&lt;pair&lt;ll, vector&lt;ll&gt;&gt;&gt;&gt;(m+1));  \n\n    for (ll i = 0; i &lt; n; i++) {  \n        for (ll j = 0; j &lt; m; j++) {  \n            if ((i+j)%2==0) {  \n                if (a[i][j] == '\\\\') {  \n                    graph[i][j].push_back({0, {i+1, j+1}});  \n                    graph[i+1][j+1].push_back({0, {i, j}});  \n                }  \n                else {  \n                    graph[i][j].push_back({1, {i+1, j+1}});  \n                    graph[i+1][j+1].push_back({1, {i, j}});  \n                }  \n            }  \n            else {  \n                if (a[i][j] == '/') {  \n                    graph[i+1][j].push_back({0, {i, j+1}});  \n                    graph[i][j+1].push_back({0, {i+1, j}});  \n                }  \n                else {  \n                    graph[i+1][j].push_back({1, {i, j+1}});  \n                    graph[i][j+1].push_back({1, {i+1, j}});  \n                }  \n            }  \n        }  \n    }  \n    vector&lt;vector&lt;ll&gt;&gt; ans(n+1, vector&lt;ll&gt;(m+1, 1e18));  \n    ans[0][0] = 0;  \n    priority_queue&lt;pair&lt;ll, vector&lt;ll&gt;&gt;, vector&lt;pair&lt;ll, vector&lt;ll&gt;&gt;&gt;, greater&lt;pair&lt;ll, vector&lt;ll&gt;&gt;&gt;&gt; pq; // {cost of reaching, x, y}  \n    pq.push({0,{0, 0}});  \n    while (!pq.empty()) {  \n        auto v = pq.top();  \n        ll w = v.first, x = v.second[0], y = v.second[1];  \n        pq.pop();  \n        for (auto c : graph[x][y]) {  \n            if (ans[c.second[0]][c.second[1]] &gt; w+c.first) {  \n                ans[c.second[0]][c.second[1]] = w+c.first;  \n                pq.push({ans[c.second[0]][c.second[1]], {c.second[0], c.second[1]}});  \n            }  \n        }  \n    }  \n    cout &lt;&lt; ans[n][m] &lt;&lt; endl;  \n}  \nint main() {  \n    ios_base::sync_with_stdio(false);  \n    cin.tie(nullptr);  \n    //___________________________  \n    solve();  \n    return 0;  \n}\n</code></pre>"},{"location":"editorials/NAOI%20TST%202025/switch/#time-complexity-analysis","title":"Time complexity Analysis","text":"<ul> <li>The solution is implementing Dijkstra's algorithm, whose time complexity is <code>O(E * log V)</code> </li> <li>Since we have <code>(n+1) * (m+1)</code> nodes, the complexity is <code>O((n*m) log(n*m))</code>, which is about <code>4.4 * 10^6</code> operations and sufficient for the constraints.</li> </ul>"},{"location":"editorials/PAIO%20TST%202025/","title":"PAIO TST 2025 Editorials","text":"<p>This directory contains editorials for the problems from the PAIO TST 2025 contest. This contest served as a selection test to select Algeria's team in the Pan-African Informatics Olympiad (PAIO) 2025.</p>"},{"location":"editorials/PAIO%20TST%202025/#problems","title":"Problems","text":"<ul> <li>Alpacas</li> <li>Carnival</li> <li>Cooling</li> <li>Garden</li> <li>Gift</li> <li>Nelward</li> <li>Plane</li> <li>Purchase</li> </ul>"},{"location":"editorials/PAIO%20TST%202025/#contest-organizers-and-contributors","title":"Contest organizers and contributors","text":"<ul> <li>Raouf Ould Ali</li> <li>Elyas Sahnoune</li> <li>Said Kebir</li> <li>Mohammed Hachem Drici</li> <li>Chams Eddine Abdelali Derreche</li> <li>Fatima Zahra Kihel</li> <li>Thamella Belaidi</li> <li>Hiba Hamidi</li> <li>Wissal Mechri</li> <li>Yousef Jaeda</li> <li>Yassir Salama</li> </ul>"},{"location":"editorials/PAIO%20TST%202025/alpacas/","title":"Alpacas","text":"<p>Written by Omar Abdelkafi Ykrelef.</p>"},{"location":"editorials/PAIO%20TST%202025/alpacas/#problem-statement","title":"Problem Statement","text":"<ul> <li>English</li> <li>French</li> <li>Arabic</li> </ul>"},{"location":"editorials/PAIO%20TST%202025/alpacas/#solution","title":"Solution","text":"<p>The problem naturally divides into two parts: minimum moves and maximum moves.</p>"},{"location":"editorials/PAIO%20TST%202025/alpacas/#minimum-number-of-moves","title":"Minimum number of moves","text":"<p>We want all alpacas to fit inside a consecutive block of length \\(n\\). If a block already contains \\(k\\) alpacas, then the number of moves needed is:</p> \\[ \\text{moves} = n - k \\] <p>So we need to maximize \\(k\\).</p>"},{"location":"editorials/PAIO%20TST%202025/alpacas/#key-idea","title":"Key idea","text":"<p>Each alpaca can act as a boundary of the block:</p> <ul> <li>If \\(A[i]\\) is the left endpoint, the block is:</li> </ul> \\[ [L, R] = [A[i], \\; A[i] + n - 1] \\] <ul> <li>If \\(A[i]\\) is the right endpoint, the block is:</li> </ul> \\[ [L, R] = [A[i] - n + 1, \\; A[i]] \\]"},{"location":"editorials/PAIO%20TST%202025/alpacas/#algorithm","title":"Algorithm","text":"<p>Step 1: Sorting</p> <p>First, sort the alpaca positions:</p> \\[ a = \\text{sorted positions} \\] <p>Now \\(a\\) is in increasing order. This makes it possible to use binary search.</p> <p>Step 2: Binary search</p> <p>To count how many alpacas lie inside \\([L, R]\\):</p> <ul> <li> <p><code>lower_bound(a.begin(), a.end(), L)</code>   \u2192 gives the first index \\(\\text{idx}_L\\) where \\(a[\\text{idx}_L] \\geq L\\).</p> </li> <li> <p><code>upper_bound(a.begin(), a.end(), R)</code>   \u2192 gives the first index after the last alpaca \\(\\leq R\\).   \u2192 subtract 1 to get the last index \\(\\text{idx}_R\\) where \\(a[\\text{idx}_R] \\leq R\\).</p> </li> </ul> <p>Now the alpacas inside \\([L, R]\\) are exactly from \\(a[\\text{idx}_L]\\) to \\(a[\\text{idx}_R]\\).</p> <p>So the count is:</p> \\[ \\text{count} = \\text{idx}_R - \\text{idx}_L + 1 \\] <p>Step 3: Applying it to our problem</p> <p>For each alpaca \\(a[i]\\), we consider two ranges:</p> <ol> <li>Treat \\(a[i]\\) as the left endpoint:</li> </ol> \\[ L = a[i], \\quad R = a[i] + n - 1 \\] <p>Count how many alpacas are inside \\([L, R]\\).</p> <ol> <li>Treat \\(a[i]\\) as the right endpoint:</li> </ol> \\[ L = a[i] - n + 1, \\quad R = a[i] \\] <p>Count how many alpacas are inside \\([L, R]\\).</p> <p>We do this with binary search for each alpaca, and keep the maximum count.</p> <p>Finally:</p> \\[ \\text{minimum moves} = n - \\max(\\text{count}) \\]"},{"location":"editorials/PAIO%20TST%202025/alpacas/#special-case","title":"Special case","text":"<p>If the formula gives <code>1</code> and the single empty position is at one end (either before the first alpaca or after the last alpaca), then the answer should be <code>2</code> (since you cannot solve it in a single move).</p>"},{"location":"editorials/PAIO%20TST%202025/alpacas/#maximum-number-of-moves","title":"Maximum number of moves","text":"<p>At first glance, you might think to count all free spots. However, alpacas cannot be moved all the way to the extreme ends.</p> <p>Define:</p> \\[ \\text{total\\_free} = (A[n] - A[1] + 1) - n \\] <p>(all empty spots between the first and last alpaca).</p> \\[ \\text{first\\_gap} = A[2] - A[1] - 1 \\] \\[ \\text{last\\_gap} = A[n] - A[n-1] - 1 \\] <p>Then the maximum number of moves is:</p> \\[ \\max(\\text{total\\_free} - \\text{first\\_gap}, \\; \\text{total\\_free} - \\text{last\\_gap}) \\]"},{"location":"editorials/PAIO%20TST%202025/alpacas/#time-complexity","title":"Time complexity","text":"<ul> <li>Finding minimum moves: \\(O(n \\log n)\\)</li> <li>Finding maximum moves: \\(O(1)\\)</li> </ul> <p>Total time complexity:</p> \\[ O(n \\log n) \\]"},{"location":"editorials/PAIO%20TST%202025/alpacas/#implementation","title":"Implementation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; a(n+1);\n\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; a[i];\n    }\n    sort(a.begin(), a.end()); // sort alpaca positions\n\n    int MIN = INT_MAX;\n\n    // Try each alpaca as both left and right endpoint\n    for (int i = 1; i &lt;= n; i++) {\n        int down = a[i] - n + 1; // block of length n ending at a[i]\n        int up   = a[i] + n - 1; // block of length n starting at a[i]\n\n        // d1 = index of first alpaca &gt;= down\n        int d1 = distance(a.begin(), lower_bound(a.begin(), a.end(), down));\n        // d2 = index of last alpaca &lt;= up\n        int d2 = distance(a.begin(), upper_bound(a.begin(), a.end(), up)) - 1;\n\n        // number of alpacas covered if we use \"down\" block\n        int ans1 = n - (abs(i - d1) + 1);\n        // number of alpacas covered if we use \"up\" block\n        int ans2 = n - (abs(i - d2) + 1);\n\n        // special case: if result = 1 and the empty spot is at the side \u2192 needs 2\n        if (a[d1] != down &amp;&amp; ans1 == 1) {\n            ans1++;\n        }\n        if (a[d2] != up &amp;&amp; ans2 == 1) {\n            ans2++;\n        }\n\n        MIN = min(MIN, min(ans1, ans2));\n    }\n    int sum = (a[n] - a[1] + 1) - n; // total free spaces\n\n    // maximum moves = max(total_free - first_gap, total_free - last_gap)\n    int MAX = max(sum - (a[n] - a[n - 1] - 1) , sum - (a[2] - a[1] - 1));\n\n    cout &lt;&lt; MIN &lt;&lt; '\\n' &lt;&lt; MAX &lt;&lt; '\\n';\n}\n</code></pre>"},{"location":"editorials/PAIO%20TST%202025/carnival/","title":"Carnival","text":"<p>Written by Raouf Ould Ali.</p>"},{"location":"editorials/PAIO%20TST%202025/carnival/#problem-statement","title":"Problem Statement","text":"<ul> <li>English</li> <li>French</li> <li>Arabic</li> </ul> <p>We are given \\(N\\) lattice points (\\(3 \\leq N &lt; 100\\)), with the guarantee that no three points are collinear. For every triple of points \\((A, B, C)\\), these form a triangle. The score of this triangle is the number of points lying strictly inside it (excluding its vertices). The task is to output, for each possible score \\(i\\), how many triangles contain exactly \\(i\\) points.</p>"},{"location":"editorials/PAIO%20TST%202025/carnival/#key-observations","title":"Key Observations","text":"<ul> <li> <p>Na\u00efve approach    For each triangle \\((A, B, C)\\), check every other point to see if it lies inside.</p> <ul> <li>This is \\(O(N^4)\\): there are \\(O(N^3)\\) triangles, and each check costs \\(O(N)\\).</li> <li>With \\(N &lt; 100\\), this is too slow.</li> </ul> </li> <li> <p>Sorting helps    The first step in the solution is to sort the points by their \\((x, y)\\)-coordinates.</p> <ul> <li>After sorting, any triangle \\((i, j, k)\\) with \\(i &lt; j &lt; k\\) will have its vertices ordered with respect to the \\(x\\) component.</li> <li>This prevents double-counting and ensures that the <code>points_below[i][j]</code> values behave consistently when we combine them.</li> </ul> </li> </ul>"},{"location":"editorials/PAIO%20TST%202025/carnival/#precomputation-points-under-a-segment","title":"Precomputation: Points under a segment","text":"<p>For two points \\(A_i\\) and \\(A_j\\) (\\(i &lt; j\\)), consider the directed segment \\((A_i \\to A_j)\\). We count how many points with indices strictly between \\(i\\) and \\(j\\) lie strictly to the right of this line.</p> <p>Formally:</p> \\[ points\\_ below[i][j] = \\#\\{ k : i &lt; k &lt; j, \\; \\text{cross}(A_j - A_i, A_k - A_i) &lt; 0 \\} \\] <p>This preprocessing costs \\(O(N^3)\\).</p>"},{"location":"editorials/PAIO%20TST%202025/carnival/#using-the-precomputation-for-triangles","title":"Using the precomputation for triangles","text":"<p>Now, for each triple \\((i,j,k)\\) with \\(i&lt;j&lt;k\\), we want to compute the number of points inside the triangle \\((A_i,A_j,A_k)\\).</p> <ul> <li>If the orientation \\((i,j,k)\\) is counter-clockwise:</li> </ul> <p>$$   \\text{inside} = points\\_below[i][k] - points\\_below[i][j] - points\\_below[j][k] - 1   $$</p> <ul> <li>If the orientation is clockwise:</li> </ul> <p>$$   \\text{inside} = points\\_below[i][j] + points\\_below[j][k] - points\\_below[i][k]   $$</p> <p>We then increment the counter:</p> \\[ O[\\text{inside}] += 1 \\]"},{"location":"editorials/PAIO%20TST%202025/carnival/#complexity-analysis","title":"Complexity Analysis","text":"<ul> <li>Sorting: \\(O(N \\log N)\\)</li> <li>Precomputation: \\(O(N^3)\\) for filling <code>points_below</code></li> <li>Triangle enumeration: \\(O(N^3)\\)</li> <li>Total: \\(O(N^3)\\), which is efficient for \\(N \\leq 100\\).</li> </ul> <p>Memory: \\(O(N^2)\\) for <code>points_below</code>.</p>"},{"location":"editorials/PAIO%20TST%202025/carnival/#implementation","title":"Implementation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n#define int long long\nusing namespace std;\n\nint cross_product(int x1, int y1, int x2, int y2)\n{\n    return x1 * y2 - x2 * y1;\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;pair&lt;int, int&gt;&gt; point(n);\n    for (int i = 0; i &lt; n; i++)\n        cin &gt;&gt; point[i].first &gt;&gt; point[i].second;\n\n    sort(point.begin(), point.end());\n\n    vector&lt;vector&lt;int&gt;&gt; points_below(n, vector&lt;int&gt;(n, 0));\n\n    for (int i = 0; i &lt; n; i++)\n        for (int j = i + 1; j &lt; n; j++)\n        {\n            for (int k = i + 1; k &lt; j; k++)\n            {\n                if (cross_product(point[j].first - point[i].first,\n                                  point[j].second - point[i].second,\n                                  point[k].first - point[i].first,\n                                  point[k].second - point[i].second) &lt; 0)\n                {\n                    points_below[i][j] += 1;\n                }\n            }\n        }\n\n    vector&lt;int&gt; O(n - 2, 0);\n\n    for (int i = 0; i &lt; n; i++)\n        for (int j = i + 1; j &lt; n; j++)\n            for (int k = j + 1; k &lt; n; k++)\n            {\n                if (cross_product(point[j].first - point[i].first,\n                                  point[j].second - point[i].second,\n                                  point[k].first - point[i].first,\n                                  point[k].second - point[i].second) &gt; 0)\n                {\n                    O[points_below[i][k] - points_below[i][j] - points_below[j][k] - 1] += 1;\n                }\n                else\n                {\n                    O[points_below[i][j] + points_below[j][k] - points_below[i][k]] += 1;\n                }\n            }\n\n    for (int i = 0; i &lt; n - 2; i++)\n        cout &lt;&lt; O[i] &lt;&lt; ' ';\n}\n</code></pre>"},{"location":"editorials/PAIO%20TST%202025/cooling/","title":"Cooling","text":"<p>Written by Iyed Baassou.</p>"},{"location":"editorials/PAIO%20TST%202025/cooling/#problem-statement","title":"Problem Statement","text":"<ul> <li>English</li> <li>French</li> <li>Arabic</li> </ul>"},{"location":"editorials/PAIO%20TST%202025/cooling/#solution","title":"Solution","text":"<p>We can notice the low constraints of both \\(n\\) (\\(1 \\le n \\le 20\\)) and \\(m\\) (\\(1 \\le m \\le 10\\)) which guides us to using a bruteforce approach. The bruteforce in this problem is finding all unique subsets of coolers and testing if they satisfy the conditions of the problem.</p>"},{"location":"editorials/PAIO%20TST%202025/cooling/#method-used","title":"Method used","text":"<p>In order to find all subsets we can use a recursive or iterative approach, we will cover both of them in this editorial.</p>"},{"location":"editorials/PAIO%20TST%202025/cooling/#recursive-approach","title":"Recursive approach:","text":"<p>We start at the first cooler and do the following: - We use a <code>line</code> array to store the number of units that power each cell. - At each cooler we can either:     - Exclude it and move to the next cooler.     - Include it, add its cost and cooling range to the line, and move to the next cooler         - Note: Remember to backtrack (remove the cooling range) after the recursion call. - When we find a subset, we need to check if the coolers cover all sections with enough units, we iterate over the intervals of each section and check if the power at each point in the interval is equal or greater than \\(C[i]\\) (\\(C[i]\\) is the units needed to cool the section \\(i\\)). <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint n, m;\nvector&lt;vector&lt;int&gt;&gt; sections, coolers;\nint mn = INT_MAX;\n\nvector&lt;int&gt; line(101, 0);\n\nvoid solve(int i, int cost) {\n    if (i == m) {\n        for (auto s: sections) {\n            for (int j = s[0]; j &lt;= s[1]; j++) {\n                if (line[j] &lt; s[2]) return;\n            }\n        }\n        mn = min(mn, cost);\n        return;\n    }\n\n    // Exclude\n    solve(i + 1, cost);\n\n    // Include\n    for (int j = coolers[i][0]; j &lt;= coolers[i][1]; j++) {\n        line[j] += coolers[i][2];\n    }\n    solve(i + 1, cost + coolers[i][3]);\n    for (int j = coolers[i][0]; j &lt;= coolers[i][1]; j++) {\n        line[j] -= coolers[i][2];\n    }\n}\n\nint main() {\n    cin &gt;&gt; n &gt;&gt; m;\n    sections.assign(n, vector&lt;int&gt;(3));\n    for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; 3; j++) cin &gt;&gt; sections[i][j];\n\n    coolers.assign(m, vector&lt;int&gt;(4));\n    for (int i = 0; i &lt; m; i++) for (int j = 0; j &lt; 4; j++) cin &gt;&gt; coolers[i][j];\n\n    solve(0, 0);\n    cout &lt;&lt; mn &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre></p> <ul> <li>Time complexity analysis:<ul> <li>Recursion: The number of subsets of an array of length m is \\(2^m\\), our recursive function finds all these subsets causing a time complexity of \\(O(2^m)\\), because at each of the \\(m\\) coolers, we call the recursion twice.</li> <li>Validation:<ul> <li>At each recursion call we add the cooling ranges to the <code>line</code> array, which is \\(O(100)\\) worst-case.</li> <li>When we find a subset and get the <code>line</code> array, we check if all sections are covered with enough units by iterating over all \\(n\\) sections and iterating over their intervals, resulting in a time complexity of \\(O(100 \\cdot n)\\).</li> </ul> </li> </ul> </li> </ul> <p>Overall time complexity: \\(O(2^m \\cdot 100 \\cdot n)\\) which is feasible under problem constraints.</p> <p>Fun fact: you can test if your code TLEs by finding time complexity and replacing the values with the upperbounds of constraints: \\(2^m \\cdot 100 \\cdot n = 2^{10} \\cdot 100 \\cdot 20 = 2048000 \\le 4 \\cdot 10^8\\) It works! \u2705</p>"},{"location":"editorials/PAIO%20TST%202025/cooling/#iterative-approach","title":"Iterative approach:","text":"<p>Instead of recursion, we can iterate over all subsets of coolers using bitmasking.</p> <ul> <li>Each cooler can either be included or not, so we represent a subset of coolers with a bitmask of length <code>m</code> by denoting excluded as a non-set 0-bit and included as a set 1-bit.</li> <li>Similar to the recursive approach, for each subset:<ul> <li>Reset a <code>line</code> array (size <code>100</code>, since positions are bounded) to 0.</li> <li>Add cooling power of the included coolers to their ranges.</li> <li>Sum up the cost of included coolers.</li> <li>Check if all sections are satisfied.</li> </ul> </li> <li>Keep track of the minimum cost across all valid subsets. <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;  \n\nint main() {\n    int n, m; cin &gt;&gt; n &gt;&gt; m;\n\n    vector&lt;vector&lt;int&gt;&gt; sections(n, vector&lt;int&gt;(3));\n    for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; 3; ++j) cin &gt;&gt; sections[i][j];  \n\n    vector&lt;vector&lt;int&gt;&gt; coolers(m, vector&lt;int&gt;(4));\n    for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; 4; ++j) cin &gt;&gt; coolers[i][j];\n\n    int mn = INT_MAX;\n    for (int mask = 0; mask &lt; (1 &lt;&lt; m); ++mask) {\n        vector&lt;int&gt; line(101, 0);\n\n        int curr = 0;\n\n        for (int i = 0; i &lt; m; ++i) {\n            if (mask &amp; (1 &lt;&lt; i)) {\n                curr += coolers[i][3];\n                for (int j = coolers[i][0]; j &lt;= coolers[i][1]; ++j) {\n                    line[j] += coolers[i][2];\n                }\n            }\n        }\n\n        bool ok = 1;\n        for (int i = 0; i &lt; n; ++i) {\n            for (int j = sections[i][0]; j &lt;= sections[i][1]; ++j) {\n                if (line[j] &lt; sections[i][2]) ok = false;\n            }\n        }\n\n        if (ok) mn = min(mn, curr);\n    }\n\n    cout &lt;&lt; mn;\n    return 0;\n}\n</code></pre></li> <li> <p>Time complexity analysis:</p> <ul> <li> <p>Subsets: There are \\(2^m\\) subsets of coolers.</p> </li> <li> <p>Processing a subset:</p> <ul> <li>Adding chosen coolers\u2019 power to <code>line</code>: each cooler can cover at most <code>100</code> positions. In worst case, all <code>m</code> coolers are included, so cost is \\(O(100 \\cdot m)\\).</li> <li>Checking all <code>n</code> sections: each section covers at most <code>100</code> positions, so validation is \\(O(100 \\cdot n)\\).</li> </ul> </li> </ul> </li> </ul> <p>Overall time complexity: \\(O(2^m\\cdot 100\\cdot (m+n))\\)</p> <ul> <li>If \\(m = 10\\) and \\(n = 20\\): \\(2^{10}\\cdot 100 \\cdot (10+30)=1024*3000=3.072 \\cdot 10^6 \\le 4 \\cdot 10^8\\) \u2705 Feasible within time limits.</li> </ul>"},{"location":"editorials/PAIO%20TST%202025/garden/","title":"Garden","text":"<p>Written by Kian Abolghasemi.</p>"},{"location":"editorials/PAIO%20TST%202025/garden/#problem-statement","title":"Problem Statement","text":"<ul> <li>English</li> <li>French</li> <li>Arabic</li> </ul>"},{"location":"editorials/PAIO%20TST%202025/garden/#full-solution","title":"Full Solution","text":"<p>The first thing one should notice is that after we trim the branches, all the leaves would be left at a distance</p> \\[ d &lt; \\max_{i=0}^{n-1} \\mathrm{dist}(0,i) &lt; n . \\] <p>So if we find a way to calculate the minimum number of operations it takes to trim the tree to a length \\(i\\) for all \\(0&lt;i \\leq \\max_{i=0}^{n-1} \\mathrm{dist}(0,i)\\), then we can pick the minimum of all the minima. </p> <p>Notice that to trim a tree to a length \\(d\\), it is clear we must remove any nodes with distances from the root more than \\(d\\). After doing so, there will be \"branches\" whose leaves are less than \\(d\\) away from the roots. We should clearly remove those too, so any node that doesn't have a leaf of distance at least \\(d\\) from the root in their subtree should be removed as well. </p> <p>These must be removed for the condition \"All leaves are of length \\(d\\)\" to be satisfied, so the minimum is at least the number of leaves we have to remove mentioned above. Now removing those is sufficient, because for every node now, it has a subtree that has a leaf of distance at least \\(d\\) from the root, and since we remove all nodes of distance more than \\(d\\), then it has a leaf of distance \\(d\\), so all the leaves are of distance \\(d\\).</p> <p>Thus, for a distance \\(i\\), the number of leaves we should remove is:</p> <ul> <li>the number of leaves of distance more than \\(i\\), plus</li> <li>the number of leaves whose maximum subtree leaf distance from the root is less than \\(i\\).</li> </ul> <p>We can first use a DFS search to get the distance from \\(0\\) for all the nodes, then we could keep a frequency array for how many nodes are of distance \\(i\\) for all \\(i\\), from which we could build a prefix array to get the number of nodes of distance more than \\(i\\).</p> <p>We then make a vector of leaves (the nodes with degree 1, which we can calculate from the input) and sort them from furthest to closest to the root. For each leaf in this vector, we keep assigning their distance as the maximum subtree leaf distance to their parents, until we meet a node with a higher maximum subtree leaf distance. Thus we have for each node the maximum subtree leaf distance, which we could again store in a frequency array, then a prefix sum array to get the number of nodes with maximum subtree leaf distance less than \\(i\\). </p> <p>Therefore, for any \\(i\\), the minimum number of operations can be found in \\(O(1)\\) with \\(O(n \\log n)\\) precomputation. Hence the overall algorithm is \\(O(n \\log n)\\).</p>"},{"location":"editorials/PAIO%20TST%202025/garden/#implementation","title":"Implementation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nvector&lt;long long&gt; dist;\nvector&lt;vector&lt;long long&gt;&gt; edge;\n\n// DFS to get distances\nvoid dfs(long long node, long long prev)\n{\n    for (auto child : edge[node])\n    {\n        if (child == prev)\n            continue;\n        dist[child] = dist[node] + 1;\n        dfs(child, node);\n    }\n}\n\nint main()\n{\n    long long n;\n    cin &gt;&gt; n;\n    vector&lt;long long&gt; deg, mxd, par;\n    deg.assign(n, 0);\n    dist.assign(n, 0);\n    mxd.assign(n, 0);\n    par.assign(n, 0);\n    cin &gt;&gt; par[0];\n    for (long long i = 1; i &lt; n; i++)\n    {\n        cin &gt;&gt; par[i];\n        deg[i]++;\n        deg[par[i]]++;\n    }\n    edge.assign(n, {});\n    for (long long i = 1; i &lt; n; i++)\n    {\n        edge[i].push_back(par[i]);\n        edge[par[i]].push_back(i);\n    }\n    dfs(0, -1);\n    vector&lt;pair&lt;long long, long long&gt;&gt; leaf;\n    for (long long i = 1; i &lt; n; i++)\n        if (deg[i] == 1)\n            leaf.push_back({dist[i], i});\n    sort(leaf.begin(), leaf.end());\n    reverse(leaf.begin(), leaf.end());\n    for (long long i = 0; i &lt; leaf.size(); i++)\n    {\n        long long ind = leaf[i].second;\n        while (mxd[ind] &lt; leaf[i].first)\n        {\n            mxd[ind] = leaf[i].first;\n            ind = par[ind];\n            if (ind == -1)\n                break;\n        }\n    }\n    long long ans = n + 1;\n    vector&lt;long long&gt; cmxd, cd;\n    cmxd.assign(n + 1, 0);\n    cd.assign(n + 1, 0);\n    for (long long i = 0; i &lt; n + 1; i++)\n        cd[i] = 0, cmxd[i] = 0;\n    for (long long i = 0; i &lt; n; i++)\n    {\n        cmxd[mxd[i]]++;\n        cd[dist[i]]++;\n    }\n    vector&lt;long long&gt; premxd, pred;\n    premxd.assign(n + 2, 0);\n    pred.assign(n + 2, 0);\n    for (long long i = 1; i &lt; n + 2; i++)\n    {\n        premxd[i] = premxd[i - 1] + cmxd[i - 1];\n        pred[i] = pred[i - 1] + cd[i - 1];\n    }\n    for (long long i = 1; i &lt;= n; i++)\n    {\n        ans = min(ans, premxd[i] + n - pred[i + 1]);\n    }\n    cout &lt;&lt; ans;\n}\n</code></pre>"},{"location":"editorials/PAIO%20TST%202025/garden/#subtasks","title":"Subtasks","text":"<ul> <li> <p>Subtask 1:   We check for the distance of all leaves. If they are not all equal, the answer is greater than 0, thus it is 1. Otherwise, the answer is 0. Complexity: \\(O(n)\\)</p> </li> <li> <p>Subtask 2:   The condition implies that the only node that has a degree more than 2 is 0, and for all other nodes they are just in one of the straight paths that start from 0 and end at the only leaf in that path. Thus, for any distance \\(i\\), to trim the tree to \\(i\\) is to reduce every path longer than \\(i\\) to \\(i\\), and every path less than \\(i\\) to 0.   We can iterate for each \\(i\\) from 1 to \\(n\\), calculating each time the number of operations we need by going over all the distinct paths and reducing them by the amount needed and increasing a counter by the reduction amount. Taking the minimum of all the final counters from 1 to \\(n\\) gives the answer. Complexity: \\(O(n^2)\\)</p> </li> <li> <p>Subtask 3:   The same condition holds, but our algorithm must be optimized since \\(n\\) is no longer small enough. The optimization is: for every path, take the distance of the leaf and insert all these leaves into a vector, sorted by distance.   Now trimming to a distance \\(i\\) not equal to the original distance of any leaf is futile, since we could do fewer operations by trimming to the distance of the leaf with least distance more than \\(i\\). So we iterate for each leaf, from smallest to largest, and notice that the number of nodes left is the distance of the leaf we chose times the number of leaves with distance larger than its own.   So the number of operations is  </p> </li> </ul> <p>$$   n - (n-i) \\cdot \\mathrm{dist}(0,\\text{leaf}_i).   $$</p> <p>We take the minimum of all the values as the answer. Complexity: \\(O(n \\log n)\\)</p> <ul> <li>Subtask 4:   Since the number of leaves is less than 10, we can brute force. Each time, choose a leaf, and let the goal distance be its distance from the root. For every other leaf, keep trimming until it either is no longer a leaf, or its distance equals that of the chosen leaf. Keeping an operations counter, we choose the minimum value. Complexity: \\(O(n)\\)</li> </ul>"},{"location":"editorials/PAIO%20TST%202025/gift/","title":"Gift","text":"<p>Written by Raouf Ould Ali.</p>"},{"location":"editorials/PAIO%20TST%202025/gift/#problem-statement","title":"Problem Statement","text":"<ul> <li>English</li> <li>French</li> <li>Arabic</li> </ul> <p>We are given an array $A$ of size \\(N\\) and an integer $K$. We start with $B = [0,0,\\dots,0]$ and want to transform it into $A$ using operations of the form:</p> <ul> <li>Choose any integer $X &gt; 0$</li> <li>Choose exactly $K$ distinct positions $P_1, P_2, \\dots, P_K$</li> <li>Add $X$ to all $B[P_j]$</li> </ul> <p>The task is to either produce a valid sequence of operations with $M \\cdot K \\leq 3 \\cdot 10^6$, or decide that it is impossible.</p>"},{"location":"editorials/PAIO%20TST%202025/gift/#step-1-feasibility-conditions","title":"Step 1: Feasibility Conditions","text":"<p>Each operation increases the total sum of $B$ by $X \\cdot K$.</p> <ul> <li>Thus,</li> </ul> <p>$$   \\text{sum} = \\sum_{i=1}^N A[i]   $$</p> <p>must be divisible by $K$.</p> <ul> <li>Let</li> </ul> <p>$$   \\text{lim} = \\frac{\\text{sum}}{K}   $$</p> <p>be the required \u201cheight\u201d of each group.</p> <ul> <li>If $\\max(A[i]) &gt; \\text{lim}$, then one element cannot fit into a single group, so the answer is impossible.</li> </ul> <p>So feasibility requires:</p> \\[ \\text{sum} \\bmod K = 0 \\quad \\text{and} \\quad \\max(A[i]) \\leq \\frac{\\text{sum}}{K}. \\]"},{"location":"editorials/PAIO%20TST%202025/gift/#step-2-grid-interpretation","title":"Step 2: Grid Interpretation","text":"<p>Visualize a grid of size $\\text{lim} \\times K$:</p> <ul> <li>The grid has height $\\text{lim}$ and width $K$.</li> <li>Each column corresponds to one bundle of size $\\text{lim}$.</li> <li> <p>We place each $A[i]$ vertically:</p> </li> <li> <p>If it fits in the current column, it stays there.</p> </li> <li>If it overflows, it continues at the top of the next column.</li> </ul> <p>Since $A[i] \\leq \\text{lim}$ for all $i$, a box never skips a column. At most it is split into two consecutive columns.</p>"},{"location":"editorials/PAIO%20TST%202025/gift/#step-3-sweeping-for-operations","title":"Step 3: Sweeping for Operations","text":"<p>Instead of outputting one operation per row (which could be up to $\\text{lim}$ rows), we notice that:</p> <ul> <li>Each column contains one index at a time.</li> <li>The index for a column only changes when one $A[i]$ ends and another begins.</li> </ul> <p>Thus, while sweeping from bottom to top:</p> <ul> <li>We keep track of the current set of active indices for all $K$ columns.</li> <li>We only output an operation when this set changes.</li> <li>The operation covers all rows since the last change, so its increment is the height difference $\\Delta h$.</li> </ul>"},{"location":"editorials/PAIO%20TST%202025/gift/#step-4-bound-on-operations","title":"Step 4: Bound on Operations","text":"<ul> <li>Each $A[i]$ can start once in a column and possibly wrap once into the next column.</li> <li>Therefore, each $A[i]$ contributes at most two changes.</li> <li>This means the total number of operations is at most $2N$, not $\\text{lim}$.</li> </ul> <p>This compression is what makes the solution efficient and ensures $M \\cdot K \\leq 3 \\cdot 10^6$.</p>"},{"location":"editorials/PAIO%20TST%202025/gift/#step-5-correctness-argument","title":"Step 5: Correctness Argument","text":"<ol> <li>Sum condition ensures the total number of increments matches.</li> <li>Max condition ensures no element overflows beyond a single column boundary.</li> <li> <p>Because $A[i] \\leq \\text{lim}$, there is no overlap in rows:</p> </li> <li> <p>Every cell of the $\\text{lim} \\times K$ grid is covered by exactly one index.</p> </li> <li>The sweep construction outputs exactly the increments needed to reach $A$, with no waste.</li> </ol> <p>Therefore, the algorithm always finds a valid solution if and only if it exists.</p>"},{"location":"editorials/PAIO%20TST%202025/gift/#example","title":"Example","text":"<p>Input:</p> <pre><code>4 2\n2 3 3 2\n</code></pre> <ul> <li>$\\text{sum} = 10$, $\\text{lim} = 5$.</li> <li>Fill the $5 \\times 2$ grid column by column:</li> </ul> <pre><code>Column 1: [1, 1, 2, 2, 2]\nColumn 2: [3, 3, 3, 4, 4]\n</code></pre> <p></p> <ul> <li> <p>Sweep rows:</p> </li> <li> <p>Rows 1\u20132: active {1,3} \u2192 operation (2, 1 3)</p> </li> <li>Row 3: active {2,3} \u2192 operation (1, 2 3)</li> <li>Rows 4\u20135: active {2,4} \u2192 operation (2, 2 4)</li> </ul> <p>Output:</p> <pre><code>3\n2 1 3\n1 2 3\n2 2 4\n</code></pre>"},{"location":"editorials/PAIO%20TST%202025/gift/#implementation","title":"Implementation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\ntypedef long long ll;\nusing namespace std;\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n\n    vector&lt;ll&gt; a(n);\n    for (int i = 0; i &lt; n; i++)\n        cin &gt;&gt; a[i];\n    ll sum = 0;\n    ll max_ai = 0;\n    for (int i = 0; i &lt; n; i++) {\n        sum += a[i];\n        max_ai = max(max_ai, a[i]);\n    }\n\n    if(sum%k != 0 or max_ai &gt; sum/k){\n        cout &lt;&lt; \"-1\\n\";\n        return 0;\n    }\n\n    ll max_height = sum/k;\n    ll current_height = 0LL;\n    ll current_column = 0LL;\n\n    vector&lt;vector&lt;ll&gt;&gt; result;\n    vector&lt;tuple&lt;ll, ll, ll&gt;&gt; cache; // height, column, index\n    for (int i = 0; i &lt; n; i++){\n        cache.push_back({current_height, current_column, i+1});\n        current_height += a[i];\n        if(current_height &gt;= max_height){\n            current_height -= max_height;\n            current_column += 1;\n            if(current_column &lt; k)\n                cache.push_back({0, current_column, i+1});\n        }\n    }\n\n    cache.push_back({max_height, 0, 0});\n\n    sort(cache.begin(), cache.end());\n\n    current_height = 0LL;\n    vector&lt;ll&gt; current_move(k+1, 0);\n\n    for(auto &amp;[height, column, index] : cache){\n        if(height != current_height){\n            current_move[0] = height - current_height;\n            result.push_back(vector&lt;ll&gt;(current_move.begin(), current_move.end()));\n            current_height = height;\n        }\n\n        current_move[column+1] = index;\n    }\n\n    cout &lt;&lt; result.size() &lt;&lt; '\\n';\n    for(auto &amp;x : result)\n    {\n        for(auto y : x) cout &lt;&lt; y &lt;&lt; ' ';\n        cout &lt;&lt; '\\n';\n    }\n}\n</code></pre>"},{"location":"editorials/PAIO%20TST%202025/nelward/","title":"Nelward","text":"<p>Written by Redhouane Abdellah.</p>"},{"location":"editorials/PAIO%20TST%202025/nelward/#problem-statement","title":"Problem Statement","text":"<ul> <li>English</li> <li>French</li> <li>Arabic</li> </ul>"},{"location":"editorials/PAIO%20TST%202025/nelward/#solution","title":"Solution","text":"<ul> <li> <p>Let \\(1 \\leq i &lt; j \\leq n\\) such that:</p> <ul> <li>\\(p_i &gt; p_j\\). Notice that \\(p_i\\) has to be moved in front of \\(p_j\\)     if we want to sort the permutation, meaning every element in     front of \\(p_i\\) also has to be moved.</li> </ul> </li> <li> <p>Let \\(1 \\leq k \\leq n\\) be the smallest index such that \\(p_k &lt; p_l\\)     for all \\(k &lt; l \\leq n\\).</p> <p>The previous observation tells us that all elements before \\(p_k\\) have to be moved, i.e.\u00c2the answer is at least</p> \\[ n - (n - k + 1) = k - 1 \\] </li> <li> <p>Notice how it is possible to move an element into any position when     performing an operation on it.</p> <p>We can do the following \\((k - 1)\\) times: move the first element into a new position \\(x \\geq k\\) such that the suffix starting at \\(k\\) stays sorted.</p> <p>Notice that after all operations the permutation is guaranteed to become sorted, hence the answer is always \\((k - 1)\\).</p> </li> </ul>"},{"location":"editorials/PAIO%20TST%202025/nelward/#implementation","title":"Implementation","text":"<ul> <li> <p>We can implement this in \\(O(n)\\) time and \\(O(n)\\) space by doing the     following:</p> <p>Traverse the array backwards starting from the \\((n-1)\\)th element, and set \\(k = n\\).</p> <p>As long as \\(p_i &lt; p_{i+1}\\) we keep traversing the array while decrementing \\(k\\) each time.</p> <p>As soon as the condition isn't met we stop decrementing \\(k\\) and traversing the array.</p> </li> </ul> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n; cin &gt;&gt; n;\n    vector&lt;int&gt; p(n);\n    for (auto &amp;i : p) cin &gt;&gt; i;\n    int k = n;\n    for (int i = n-2; i &gt;= 0; --i) {\n        if (p[i] &lt; p[i+1]) --k;\n        else break;\n    }\n    cout &lt;&lt; k-1;\n}\n</code></pre> <ul> <li> <p>We can reduce the space complexity to \\(O(1)\\) by doing the following:</p> <p>Set \\(k = 1\\), let \\(a = p_1\\).</p> <p>Then for all \\(1 &lt; i \\leq n\\): let \\(b = p_i\\).</p> <p>If \\(a &gt; b\\), we set \\(k = i\\) (because now the left endpoint of the longest increasing suffix is guaranteed to be \\(\\geq i\\)), and then set \\(a = b\\) before moving to \\(i+1\\).</p> <p>Here's the code for it:</p> </li> </ul> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n; cin &gt;&gt; n;\n    int a, b;\n    cin &gt;&gt; a;\n    int k = 1;\n    for (int i = 2; i &lt;= n; ++i) {\n        cin &gt;&gt; b;\n        if (a &gt; b) k = i;\n        a = b;\n    }\n    cout &lt;&lt; k-1;\n}\n</code></pre>"},{"location":"editorials/PAIO%20TST%202025/plane/","title":"Plane","text":"<p>Written by Haithem Djefel.</p>"},{"location":"editorials/PAIO%20TST%202025/plane/#problem-statement","title":"Problem Statement","text":"<ul> <li>English</li> <li>French</li> <li>Arabic</li> </ul>"},{"location":"editorials/PAIO%20TST%202025/plane/#solution","title":"Solution","text":"<p>We can use a dynamic programming approach, let \\(dp_i\\) denote the minimum cost for omar to survive until minute \\(T_i\\), our base case is \\(dp_{-1} = 0\\), and our transition will be the following: </p> <p>For each \\(i \\in \\{0, 1,..., n - 1\\}\\), \\(dp_i = min(dp_{i - 1} + p, dp_{k - 1} + q)\\), where k is the index of the smallest \\(T_j\\) such that \\(T_j + m - 1 \\leq T_i\\). </p> <p>We visit each state exactly once, and at each state, we can find \\(dp_{i - 1}\\) in \\(O(1)\\), and \\(dp_{k - 1}\\) can be found in \\(O(\\log n)\\) using a binary search since the array \\(T\\) is sorted. our final answer will be \\(dp_{n - 1}\\). </p> <p>Now for the construction (i.e. finding the optimal way Omar should use the masks or perfume), this might seem tricky at first, but it could be done with just slight additions to our approach. </p> <p>We can treat our dp states as a DAG (directed acyclic graph), where each state is a node, and the parent for a state is the state that leads to it (i.e. choosing the mask or perfume); this way, we can start at state \\(n - 1\\) and continue traversing its parents until its first ancestor (state 0) \\ total time complexity: \\(O(n\\log n)\\)</p>"},{"location":"editorials/PAIO%20TST%202025/plane/#implementation","title":"Implementation","text":"<p>Below is an implementation of the aforementioned idea using a bottom-up dp approach:</p> <pre><code>cpp\n// PAIO TST solution code for planes by Haithem Djefel\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\ntypedef long long ll;\n\n#define Algerian ios::sync_with_stdio(0);\n#define OI cin.tie(0);\n\nint main() {\n    Algerian OI\n\n    ll n, m, p, q; \n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; p &gt;&gt; q;\n    vector&lt;ll&gt; t(n);\n\n    for (ll i = 0; i &lt; n; i++) cin &gt;&gt; t[i];\n\n    vector&lt;ll&gt; dp(n);\n    vector&lt;ll&gt; par(n);\n\n    for (ll i = 0; i &lt; n; i++) {\n        dp[i] = (i &gt; 0 ? dp[i - 1] : 0) + p;\n        auto it = lower_bound(t.begin(), t.end(), t[i] - m + 1);\n\n        ll val = 0;\n        if (it != t.begin()) {\n            ll idx = (--it) - t.begin();\n\n            val = dp[idx];\n        }\n        val += q;\n\n        if (val &lt;= dp[i]) {\n            par[i] = 2;\n            dp[i] = val;\n        } else {\n            par[i] = 1;\n        }\n    }\n\n    cout &lt;&lt; dp[n - 1] &lt;&lt; \"\\n\";\n\n    ll x = n - 1;\n\n    vector&lt;ll&gt; res(n);\n\n\n    while (x &gt;= 0) {\n        if (par[x] == 1) {\n            res[x] = 1;\n            x--;\n        } else if (par[x] == 2) {\n            auto it = lower_bound(t.begin(), t.end(), t[x] - m + 1);\n            ll idx = it - t.begin();\n            res[idx] = 2;\n            x = idx - 1;\n        }\n    }\n\n    for (ll i = 0; i &lt; n; i++) cout &lt;&lt; res[i] &lt;&lt; \" \\n\"[i == n - 1];\n}\n</code></pre>"},{"location":"editorials/PAIO%20TST%202025/purchase/","title":"Purchase","text":"<p>Written by Fares Khelif.</p>"},{"location":"editorials/PAIO%20TST%202025/purchase/#problem-statement","title":"Problem Statement","text":"<ul> <li>English</li> <li>French</li> <li>Arabic</li> </ul>"},{"location":"editorials/PAIO%20TST%202025/purchase/#solution","title":"Solution","text":"<p>Naive Approach :  - For each suitcase, we compute the number of souvenirs we can fit with two nested for loops as shown in the pseudocode : <pre><code>vector&lt;int&gt; ans(M)\nfor(each Suitcase(of index j) in S) {\n    int elements = 0\n    int sum = 0\n    for (each Souvenir(of index i) in P) {\n         if (we can fit all souvenirs of weight i in the Suitcase) {\n             // Put all of them inside of it\n             sum += the weight of all elements\n             elements += P[i]\n         }\n         else {\n             // Put as much as we can inside of it\n             sum += the maximum weight we can fit inside of it\n             elements += the number of elements corresponding the the maximum weight\n        }\n     }\n     ans[j] = elements\n}\n</code></pre></p> <ul> <li>The main problem here is the time complexity :<ul> <li>For each Suitcase, we compute the maximum number of souvenirs we're able to put in it by iterating over all possible weights of the souvenirs</li> <li>Since we have T Suitcases and M possible weights of the Souvenirs, this will result in a TC of \\(O(T \\times M)\\) which is insufficient with such constraints(\\(10^5 \\times 10^5 = 10^{10}\\) (Too large!))</li> </ul> </li> <li> <p>Key Optimization :</p> <ul> <li>Instead of reiterating over all possible weights in P for every Suitcase, we can see that if we sort the array S while keeping the index of each suitcase for the output, we won't have to recompute computed suitecases, since we always start from the smallest weight, the large suitcase is going to fit what the small suitcase fitted, and it will still have the capacity to fit other souvenirs, and that's only what the optimized algorithm is going to compute</li> <li>As you can see the fully working code I wrote, which guarantees a 100%</li> </ul> </li> <li> <p>Time complexity: </p> <ul> <li>Since we don't recompute the previously computed weights, we have that i only does a single iteration over the array P which results in the fast : \\(O(T+M)\\)</li> <li>Which is guaranteed to work since \\(T, M \\leq 10^5\\), thus we have \\(2 \\times 10^5\\) operations at most</li> </ul> </li> </ul>"},{"location":"editorials/PAIO%20TST%202025/purchase/#implementation","title":"Implementation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define endl '\\n'\nusing ll  = long long;\nusing pll = pair&lt;ll, ll&gt;;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    //___________________________\n    ll t, m; cin &gt;&gt; t &gt;&gt; m;\n    vector&lt;ll&gt; s(t);\n    vector&lt;pll&gt; p(m);\n    for (ll i = 0; i &lt; t; i++) cin &gt;&gt; s[i];\n    for (ll i = 0; i &lt; m; i++) cin &gt;&gt; p[i].first, p[i].second = i;  // Essential step  No.1\n\n    sort(p.begin(), p.end());  // Essential step  No.2\n\n    vector&lt;ll&gt; ans(m);\n    ll i = 0; // Declare i as a global variable to not recompute computed values (avoids TLE)\n    ll sum = 0, el = 0;\n    for (ll j = 0; j &lt; m; j++) {\n        for (; i &lt; t; i++) {  // We don't need to declare i every time\n            if (p[j].first-sum &gt;= s[i]*i) { // If we can put all the weights in the suitcase\n                el += s[i];\n                sum += s[i]*i;\n                s[i] = 0;\n            }\n            else {  // If we can put some of it\n                ll a = ((p[j].first-sum)/i);\n                el += a;\n                sum += a*i;\n                s[i] -= a;\n                break;\n            }\n        }\n        ans[p[j].second] = el;  // Assign the answer to each suitcase\n    }\n\n    // Output the answers :\n    for (auto c : ans) cout &lt;&lt; c &lt;&lt; ' ';\n    cout &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"fundamentals/intro-to-c%2B%2B/","title":"Introduction to C++","text":""},{"location":"fundamentals/intro-to-c%2B%2B/#what-is-c","title":"What is C++?","text":"<p>C++ is one of the most widely used programming languages in competitive programming, software development, and system programming. It is known for:</p> <ul> <li>Speed &amp; efficiency (close to the hardware, used in high-performance applications).</li> <li>Flexibility (supports both procedural and object-oriented programming).</li> <li>Rich standard library (STL) with powerful tools like vectors, sets, maps, and algorithms.</li> </ul> <p>Because of its performance and versatility, C++ is the main language used in the International Olympiad in Informatics (IOI) and most competitive programming contests.</p>"},{"location":"fundamentals/intro-to-c%2B%2B/#why-do-we-need-vs-code","title":"Why do we need VS Code?","text":"<p>Visual Studio Code is a free, lightweight, and powerful code editor. For C++ learners, it is useful because:</p> <ul> <li>It supports extensions (C++ IntelliSense, debugging, formatting).</li> <li>It works on Windows, Linux, and macOS.</li> <li>It makes it easier to compile, run, and debug C++ programs.</li> <li>It integrates well with Git, so you can manage your projects and track changes easily.</li> </ul> <p>\ud83d\udc49 Watch this short video tutorial to install VS Code for C++: \ud83c\udfa5 How to Install VS Code for C++</p>"},{"location":"fundamentals/intro-to-c%2B%2B/#learning-resources-for-c","title":"\ud83d\udcda Learning Resources for C++","text":""},{"location":"fundamentals/intro-to-c%2B%2B/#1-step-by-step-tutorials","title":"1. Step-by-step tutorials","text":"<ul> <li>France-IOI \u2013 courses and problems in French.</li> <li>W3Schools C++ \u2013 beginner-friendly, interactive tutorials.</li> <li>SoloLearn C++ \u2013 interactive mobile/web platform.</li> <li>Book \u2013 A Complete Guide to Programming in C++ (Volkov) \u2013 complete PDF textbook.</li> <li>GeeksforGeeks \u2013 tutorials and practice problems in C++.</li> </ul>"},{"location":"fundamentals/intro-to-c%2B%2B/#2-video-playlists","title":"2. Video Playlists","text":"<ul> <li>EOI C++ Playlist (Arabic)</li> <li>C++ Playlist en Fran\u00e7ais</li> <li>C++ Playlist in English</li> </ul>"},{"location":"fundamentals/intro-to-c%2B%2B/#3-practice-platforms","title":"3. Practice Platforms","text":"<ul> <li>LeetCode \u2013 practice coding problems with increasing difficulty.</li> <li>France-IOI \u2013 also doubles as a practice platform for beginners.</li> <li>AtCoder \u2013 Japanese competitive programming platform with regular contests.</li> <li>CSES Problem Set \u2013 a collection of competitive programming problems.</li> <li>Codeforces \u2013 competitive programming contests and problem archives.</li> </ul>"},{"location":"fundamentals/time-complexity/","title":"Time Complexity","text":"<p>Contribution by Raouf Ould Ali.</p> <p>One of the most important aspects of writing efficient code is understanding the time complexity of algorithms. Time complexity is a way to express how the runtime of an algorithm grows relative to the input size. It helps analyze and compare the efficiency of different algorithms.</p> <p>Here are some useful resources to understand time complexity:</p>"},{"location":"fundamentals/time-complexity/#documents-and-articles","title":"Documents and Articles","text":"<ul> <li>The Incarnadine Training Units - Time Complexity (en)</li> <li>Competitive Programming Handbook - Chapter 2 (en)</li> <li>A Time Complexity Guide (en)</li> </ul>"},{"location":"fundamentals/time-complexity/#videos","title":"Videos","text":"<ul> <li>Learn Big O notation in 6 minutes - Bro Code (en)</li> <li>Big-O Notation in 5 minutes (en)</li> <li>Intro to Time Complexity for CP (en)</li> <li>\u0634\u0631\u062d \u0645\u0641\u0647\u0648\u0645 \u0627\u0644\u0640 Big O - Notation (ar)</li> <li>Time Complexity Analysis (ar)</li> </ul>"},{"location":"math/proof-writing/","title":"Prove it !","text":"<p>Contribution by Said Kebir.</p> <p>To many students, mathematics is no more than finding numerical answers to problems. However, there is much more. Being able to prove your assertions is at least as important as finding the answer. Unfortunately, most schools neglect proofs or confine them to geometry classes, when proofs are important to all fields of mathematics. Moreover, proofs are usually presented in a dry, methodical way to emphasize rigor, when real mathematical proofs are written with more words than equations.</p>"},{"location":"math/proof-writing/#1-words-words-words","title":"1. Words, Words, Words","text":"<p>Proof problems and solutions have a special and subtle vocabulary of their own. Many of these terms confuse beginning students, so we'll go over them.</p> <ul> <li> <p>When a problem asks us to solve something about distinct objects or numbers, it means that the objects or numbers in question are all different. For example, if we are asked to solve a question involving 3 distinct integers, the numbers cannot be 2,3 , and 2 .</p> </li> <li> <p>When we say without loss of generality, we mean that we have chosen a specific case to solve, but the specific case really doesn't matter. By solving the assertion for that specific case, we prove it for all cases, as all cases are qualitatively the same; only the ordering of names or correlations is different.</p> </li> </ul> <p>EXAMPLE 1 Show that if \\(x+y+z=7\\) and \\(x, y\\), and \\(z\\) are distinct positive integers, then one of these numbers must be 4.</p> <p>Proof: Assume without loss of generality that \\(x&lt;y&lt;z\\). We can do this since we know the numbers are distinct and it doesn't really matter which is which. (While \\((1,2,4)\\) and \\((2,1,4)\\) are considered different solutions, they still consist of the same three numbers.) If \\(x=2\\), the sum \\(x+y+z\\) is at least \\(2+3+4=9\\), which is too big. Thus \\(x=1\\). Similarly, if \\(y=3\\), the sum is at least \\(1+3+4=8\\); thus, \\(y=2\\) and \\(z=4\\). Hence, one of the numbers (the largest) must always be 4 . By using \"without loss of generality\" as we have, we have just named the largest integer \\(z\\), the smallest \\(x\\), and the other \\(y\\). We can permute these labels in any way and the problem will be unchanged. Thus, all solutions can be found by permuting \\((1,2,4)\\).</p> <p>EXAMPLE 2 Why can't we use \"without loss of generality\" as above on a problem involving \\(x+2 y+3 z=1\\) ?</p> <p>Solution: The quantities in this problem are not interchangeable. Switching \\(x\\) and \\(z\\) yields \\(z+2 y+3 x=1\\), which is qualitatively different from the original \\(x+2 y+3 z=1\\). (For example, \\((x, y, z)=(1,0,0)\\) is a solution of one equation but not the other.) In the previous problem, switching \\(x\\) and \\(z\\) yields \\(z+y+x=7\\), which is not qualitatively different from \\(x+y+z=7\\). This is the heart of \"without loss of generality\"; changing the labels does not change the problem.</p> <ul> <li>In problems in which we are asked to maximize a quantity, we are actually asked to do two things. We must show that the maximum can be attained and that no value greater than that maximum can be attained. Just doing one of these is insufficient. The same, of course, holds for minimization.</li> </ul> <p>EXAMPLE 3 Find the maximum value of \\(x+y\\) if \\(x \\leq 3\\) and \\(y \\leq 5\\).</p> <p>Solution: Clearly \\(x+y\\) is always less than 9 , since \\(x+y \\leq 3+5\\). However, 9 is not the maximum, since it is never attained! The true maximum is 8 , since that is the largest value which can be attained.</p> <ul> <li> <p>A solution to a problem is called trivial if the numbers present in the problem have no use in determining that solution. Trivial solutions are those solutions which are blatantly obvious and have little mathematical value, so problems often ask the solver to find nontrivial solutions. For example, when solving the equation \\(x^{2}+y^{2}=z^{2},(0,0,0)\\) is a trivial solution. Generally, any solution in which all the variables equal 0 is a trivial solution. If on a test you are unsure whether a solution you have found is trivial or not, assume it is not trivial; if you had to think at all to find the solution, it probably isn't. As another example, when asked for the nontrivial factors of an integer, we want those factors besides 1 and the number itself.</p> </li> <li> <p>Sometimes proofs are so long that we want to break up the proof into smaller parts. After we prove each of these smaller parts, we combine them to complete the proof. In the text of a proof, these smaller parts are called lemmas. There aren't any proofs in this volume complicated enough to require lemmas, but there are some in the second volume. A proof is rigorous when the proof is complete with no unproven assumptions.</p> </li> <li> <p>A number is even if and only if it is divisible by two. Why do we say \"if and only if\" rather than just \"if\" or just \"only if?\" What is the difference? When we say a number is even if it is divisible by two, we do not exculde the possibility that a number which is not a multiple of two is even. By just saying a number is even only if it is divisible two, we don't say that all multiples of two are even. Only by combining the two in \"if and only if\" can we say both that a number must be a multiple of two to be even and that all multiples of two are even. Mathematicians often write \"iff\" rather than \"if and only if,\" so don't assume it's a typographical error.</p> </li> </ul> <p>EXERCISE 1 Do you need \"if,\" \"only if,\" or \"iff\" in the following?</p> <p>i. A number ends with a \\(5 \\ldots\\) it is divisible by five.</p> <p>ii. An animal is a mammal. . . it is a human.</p> <p>iii. A figure is a circle. . . every point on it is a common distance from some center.</p> <p>iv. A number is an integer... it has no fractional part.</p> <p>Proving facts involving if and only if usually requires two steps; the \"if\" and \"only if\" parts are generally proved separately. The examples at the end of this section will demonstrate this.</p> <ul> <li>That a number is a multiple of two is necessary and sufficient for the number to be even. \"Necessary and sufficient\" is just another way of saying \"if and only if.\" By \"necessary,\" we mean that it is necessary for a number to be a multiple of two in order to be even. As with \"only if,\" this does not imply that all multiples of two are even. By \"sufficient,\" we say that any multiple of two is even, but like \"if,\" this does not exclude numbers which are not multiples of two from being even. Only by putting together both of these can we say all multiples of two and only multiples of two are even. Once again, proofs of facts involving necessary and sufficient usually involve proving the two separately.</li> </ul> <p>EXAMPLE 4 Prove that the product of two integers is odd if and only if both of the integers are odd.</p> <p>Proof: To show the \"if\" part, we write our odd integers as \\(2 n+1\\) and \\(2 m+1\\). The product of these is \\((2 n+1)(2 m+1)=4 m n+2 m+2 n+1\\), which is odd because it isn't evenly divisible by two.</p> <p>To show the \"only if,\" we must show that the product of two even numbers and the product of an even number and an odd number are both even. First, letting the two even numbers be \\(2 n\\) and \\(2 m\\), the product is \\(4 m n\\), which is divisible by 2 . Second, letting the even number be \\(2 n\\) and the odd \\(2 m+1\\), the product is \\((2 n)(2 m+1)=4 m n+2 n\\), which is divisible by 2 and hence even. Thus the product of two integers is odd iff both the integers are odd.</p> <p>EXAMPLE 5 Show that \\(x\\) being a multiple of 3 is a necessary and sufficient condition for \\(x\\) to be a solution of \\(\\lfloor x / 3\\rfloor-x / 3=0\\).</p> <p>Proof: Write the equation as \\(x / 3=\\lfloor x / 3\\rfloor\\). Since \\(\\lfloor x / 3\\rfloor\\) is always an integer, \\(x / 3\\) must be an integer. Hence, it is necessary for \\(x\\) to be a multiple of 3 . To show that it is sufficient that \\(x\\) be a multiple of 3 , let \\(x=3 n\\) for some integer \\(n\\). Then \\(\\lfloor x / 3\\rfloor-x / 3=\\lfloor n\\rfloor-n=0\\), so all multiples of 3 are solutions to the equation \\(\\lfloor x / 3\\rfloor-x / 3=0\\).</p>"},{"location":"math/proof-writing/#2-contradiction","title":"2. Contradiction","text":"<p>Is too! Is not! Is too! Is not!</p> <p>This is an age old argument of children everywhere. Suppose you are arguing that something \"Is too!\" The most obvious way to show that it is such is to show that it is indeed true; however,</p> <p>there is another way. Instead of showing that you are right, show that your adversary is wrong. If our opponent is wrong, then you must be right. This is the heart of contradiction.</p> <p>A simple example of the use of contradiction is the proof that there are infinitely many prime numbers. Rather than try to prove that there are infinitely many primes directly, we prove that the opposite is impossible-i.e., it is impossible that there is a finite number of primes.</p> <p>EXERCISE 2 review the proof that there are infinitely many primes.</p> <p>EXAMPLE 6 Prove that if \\(x\\) is a real solution to \\(x^{5}+3 x^{2}+7 x+2=0\\), then \\(x\\) must be negative.</p> <p>Proof: First, \\(x=0\\) is clearly not a solution. Second, if \\(x&gt;0\\), then \\(x^{5}+3 x^{2}+7 x+2\\) is the sum of four positive terms and hence cannot be equal to zero. Thus no positive \\(x\\) can be a solution to the equation. Hence, we have shown by contradiction that if \\(x\\) is a solution to the given equation, it cannot be nonnegative, so any real solution \\(x\\) must be negative.</p> <p>EXERCISE 3 Prove that if \\(a, b, c&gt;0\\), then if \\(a x^{2}+b x+c=0\\) has real solutions, both solutions are negative.</p>"},{"location":"math/proof-writing/#3-converses-arent-necessarily-true","title":"3. Converses Aren't Necessarily True","text":"<p>All dogs have noses; therefore, anything with a nose is a dog. Clearly this argument is ridiculous; however, people will often give arguments like this to prove mathematical facts.</p> <p>Given a statement like \"If an animal is a dog, then it has a nose,\" the converse of the statement is \"If an animal has a nose, then it is a dog.\" Notice that we have just swapped the positions of \"dog\" and \"nose;\" that is what the converse is. The inverse is \"If an animal is not a dog, then it does not have a nose\"; we have just negated \"nose\" and \"dog.\" The contrapositive is \"If an animal does not have a nose, the animal is not a dog.\" Here we have both swapped \"dog\" and \"nose\" and negated them.</p> <p>From our examples, it is clear that if a statement is true, its converse and inverse are not necessarily true. Indeed, the converse and inverse of our sample statement about dogs' noses are quite ridiculous. The contrapositive of a true statement, however, is always true. Do you see why?</p> <p>While it important to understand that the contrapositive of a statement is always true, it is equally important to see that the converse may or may not be true. Hence, when asked to prove a statement which is the converse of a true statement, the original statement is irrelevant. You must prove the converse separately.</p> <p>EXAMPLE 7 What are the converse, inverse, and contrapositive of the statement, \"If Jim is outside, it is raining?\" Which of these must be true if the statement is true?</p> <p>Solution: The converse is \"If it is raining, Jim is outside.\" The inverse is \"If Jim is not outside, it is not raining.\" The contrapositive is \"If it is not raining, Jim is not outside.\" The contrapositive is the only one which must be true if the statement is true.</p>"},{"location":"math/proof-writing/#4-mathematical-induction","title":"4. Mathematical Induction","text":"<p>Mathematical induction is a powerful tool when we are asked to prove something is true for integers. It works like this. Suppose we are asked to prove that a given assertion is true for all positive integers. First, we show that it is true for 1 (or some other base case, often 0 ). Second, we show that if it is true for some integer \\(k\\), then it must be true for the number \\(k+1\\). This is the inductive step. Having proved this we argue that, since it is true for 1 , it must be true for \\(1+1=2\\). Since it is true for 2 , it is true for \\(2+1=3\\), and so on. Thus the assertion is true for all positive integers.</p> <p>For example, let's show that</p> \\[ 1+2+3+\\cdots+n=\\frac{n(n+1)}{2} \\] <p>First, we show it is true when \\(n=1\\). This is obvious, as</p> \\[ 1=\\frac{1(1+1)}{2} \\] <p>Now, we show that if it is true for \\(k\\), it must also be true for \\(k+1\\). If the assertion is true for \\(k\\), we have</p> \\[ 1+2+3+\\cdots+k=\\frac{k(k+1)}{2} \\] <p>Now, we must evaluate the sum of the integers from 1 to \\(k+1\\) :</p> \\[ \\begin{aligned} 1+\\cdots+k+(k+1)=(1+\\cdots+k)+(k+1) &amp; =\\frac{k(k+1)}{2}+(k+1) \\\\ &amp; =\\frac{k}{2}(k+1)+(k+1) \\\\ &amp; =\\left(\\frac{k}{2}+1\\right)(k+1) \\\\ &amp; =\\frac{(k+1+1)(k+1)}{2} \\end{aligned} \\] <p>Thus, we have shown that if</p> \\[ 1+2+3+\\cdots+n=\\frac{n(n+1)}{2} \\] <p>is true for \\(n=k\\), then it is true for \\(n=k+1\\). Since it is true for \\(n=1\\), it is therefore true for \\(2,3,4, \\ldots\\), that is, all positive integers.</p> <p>Ordinarily when using induction, we don't have to explain \"Since it is true for...\" We must merely prove the initial case, prove the inductive step, then assert that the induction is complete. The following example is a model of the use of induction as it should appear in texts, or on test papers.</p> <p>EXAMPLE 8 Show that for all positive integers \\(n\\),</p> \\[ 7+6 \\cdot 7+6 \\cdot 7^{2}+6 \\cdot 7^{3}+\\cdots+6 \\cdot 7^{n}=7^{n+1} \\] <p>Proof: For \\(n=1\\), we have \\(7+6 \\cdot 7=49=7^{1+1}\\), so the assertion is true for \\(n=1\\). If the assertion is true for \\(n=k\\), we have</p> \\[ 7+6 \\cdot 7+6 \\cdot 7^{2}+6 \\cdot 7^{3}+\\cdots+6 \\cdot 7^{k}=7^{k+1} \\] <p>Thus,</p> \\[ \\begin{aligned} 7+6 \\cdot 7+\\cdots+6 \\cdot 7^{k+1}=\\left(7+6 \\cdot 7+\\cdots+6 \\cdot 7^{k}\\right)+6 \\cdot 7^{k+1} &amp; =7^{k+1}+6 \\cdot 7^{k+1} \\\\ &amp; =(1+6) 7^{k+1} \\\\ &amp; =7^{k+1+1} \\end{aligned} \\] <p>This proves the inductive step and our induction is complete.</p> <p>EXERCISE 4 Consider the following \"proof\" that every person in the world is the same height. Step one: In a group of 1 , every person is the same height. Step 2: Given that in any group of \\(k\\) people the people are all the same height, we show that any group of \\(k+1\\) people must consist of people who are all the same height. We do this as follows. Given a group of \\(k+1\\) people, we remove one. The other \\(k\\) must be the same height, since they are a group of \\(k\\) people. Now replace the removed person and take someone else out. This also leaves a group of \\(k\\) people of the same height including the first removed person. This person is then the same height as the other \\(k\\). Hence, any group of \\(k+1\\) people is a group of people who are all the same height. This completes the inductive step, so all people are the same height.</p> <p>Clearly something is wrong with this. What?</p>"},{"location":"math/proof-writing/#5-shooting-holes-in-pigeons","title":"5. Shooting Holes in Pigeons","text":"<p>Consider a flock of \\(n+1\\) pigeons. Due to space constraints, the pigeons' home only has \\(n\\) holes (bear with us). If the flock flies home for the summer, there must be at least one hole with 2 or more pigeons in it. Do you see why?</p> <p>This is the simplest statement of the Pigeonhole Principle. (It is also called Dirichlet's Principle, probably because he was the first to realize that such an obvious theorem could be useful.) In fact, the Principle is highly useful in math, especially in nonobvious settings.</p> <p>EXAMPLE 9 Given 7 points on a line segment of length 1, prove that there must exist two of the points separated by no more than \\(1 / 6\\).</p> <p>Proof: Divide the line segment into six equal length segments. By the Pigeonhole Principle, two of the points must lie on one of these segments (including endpoints). These two points will be at most \\(1 / 6\\) apart, because they lie on a segment of length \\(1 / 6\\).</p> <p>The hardest part of applying the Principle, besides realizing that it might be useful to the problem at hand, is determining the pigeonholes. They will almost invariably be simple, like dividing an interval into equal pieces or a square into equal squares.</p> <p>The version of the Principle we are using is a little too weak for general use. We can easily strengthen it by modification. Consider a flock of \\(2 n+1\\) pigeons, with the same \\(n\\) holes. Now there must be some hole with at least three pigeons. The general statement and the easy proof are as follows.</p> <p>The Pigeonhole Principle. Given \\(k n+1\\) objects which are in \\(n\\) boxes, there must be some box with at least \\(k+1\\) objects.</p> <p>Proof: We use the principle of proof by contradiction. Suppose that the \\(n\\) boxes each have \\(k\\) or fewer objects. The total number of objects is then less than or equal to \\(n k\\). But the total number is given to be \\(n k+1\\), so this gives \\(n k+1 \\leq n k\\), a contradiction. So our original supposition that there was no box with \\(k+1\\) or more objects must be false.</p> <p>The Pigeonhole Principle crops up in a surprising variety of disguises. With some experience, you should learn to identify them.</p> <p>EXERCISE 5 A group of \\(n\\) people are selecting entrees at a restaurant. All the entrees are either pasta, seafood, beef, chicken, or vegetarian. Find the smallest possible \\(n\\) such that we can be sure that at least 3 people have dishes from the same category. Prove your answer.</p>"},{"location":"math/proof-writing/#6-convincing-but-wrong","title":"6. Convincing But Wrong","text":"<p>When you compare a proof you have written for a problem to one offered as the \"right\" proof, you will often find that yours is different from the proposed solution. However, don't assume your proof is wrong. Unlike \"find the answer\" questions, proofs have many different right answers.</p> <p>Unfortunately, they also have many wrong ones. And no matter how convincing it is, a wrong proof is still wrong. For this reason, if your proof differs from the \"correct\" solution, don't automatically assume your proof is just a different way to solve the problem. Challenge your solution; check each link in your chain of reasoning to make sure it is sound.</p> <p>In this section we discuss convincing but wrong arguments. We'll begin by proving that \\(-1=1\\), starting from \\(1+1=2\\). Our steps are as follows: \\(1+1=2\\), so \\(1-2=-1\\), so \\((1-2)^{2}=(-1)^{2}\\), so \\((1-2)^{2}=1\\), so \\(\\sqrt{(1-2)^{2}}=\\sqrt{1}\\), so \\(1-2=1\\), so \\(-1=1\\). Clearly our conclusion, \\(-1=1\\), is wrong, but our premise, \\(1+1=2\\), is correct. So one of our steps must be faulty. Analyzing our \"proof\" closely, we see that our erroneous step is going from \\(\\sqrt{(1-2)^{2}}=\\sqrt{1}\\) to \\(1-2=1\\). We have taken the negative square root on the left rather than the positive square root. The moral of the story? It is easy to hide a wrong step amidst a barrage of correct ones.</p> <p>Convincing but wrong proofs often include showing patterns without proving them. Recognizing a pattern is essential to problem solving, but noting that a pattern exists does not constitute a proof.</p> <p>For example, suppose we are asked to find a closed form for</p> \\[ 2^{0}+2^{1}+2^{2}+\\cdots+2^{n} \\] <p>(A closed form for a sum is one which can be immediately evaluated by plugging in the variable; there can be no summations left.) If we evaluate the sum for \\(n=1,2\\), and 3 , we find that the answers are \\(2^{2}-1,2^{3}-1\\), and \\(2^{4}-1\\), respectively. From these results, we might try to deduce that a general closed form for the sum is \\(2^{n+1}-1\\). But this is no proof. Seeing a pattern of this type is important in finding a general rule, but not in proving it.</p> <p>A common mistake in wrong proofs is circular reasoning. Circular reasoning occurs when we use a statement to prove itself. This may sound easy to avoid, but as the following examples show, a circular assumption can be buried very deeply; in working a complex problem it is easy to forget which statements you know and which you are trying to prove.</p> <p>EXAMPLE 10 What's wrong with the following \"proof\"?</p> <p>Suppose 5 women and 5 men are seated at a round table such that each person sits between 2 people of the opposite sex. We shall prove that if we number the chairs from 1 to 10 in order, a woman must be seated in chair 1.</p> <p>If a woman is in chair 1, a man must be in chair 2, so a woman must be in chair 3, and so forth, until we conclude that a man is in chair 10. Since chair 10 is next to chair 1, a woman must be in chair 1 .</p> <p>Solution: We wish to show that a woman is in chair 1, but our first step in the erroneous proof assumes that a woman is in chair 1 . We are guilty of circular reasoning-we must not in any step assume what we are trying to prove is true.</p> <p>EXAMPLE 11 What's wrong with this proof that if \\(|x|+x&gt;0\\), then \\(x&gt;0\\) ?</p> <p>Since \\(|x|=x\\), then \\(|x|+x=2 x\\). Thus \\(2 x&gt;0\\), so \\(x&gt;0\\).</p> <p>Solution: This example shows that circular reasoning can be used to prove a true statement incorrectly. Our first step in the \"proof\" is \\(|x|=x\\); but this is only true if \\(x \\geq 0\\) ! Thus in writing \\(|x|=x\\), we assume that \\(x \\geq 0\\), which is what we are trying to prove. Again we are guilty of circular reasoning. (Among the problems at the end of this chapter, the reader is challenged to find a sound proof for the assertion of this problem.)</p> <p>EXERCISE 6 Find what's wrong with the following proof and provide a sound alternative.</p> <p>There are 21 students in a ten minute class. Each student sleeps for a total of 1 minute during the class. Prove that there is some moment when at least three students are asleep.</p> <p>Proof: Two students sleep during the first minute, two during the second, and so on, for a total of 20 students sleeping for a minute during the 10 minute class. The remaining student must sleep during one of these minutes as well, so there must be 3 students sleeping during the same minute.</p>"},{"location":"math/proof-writing/#7-problems-to-solve","title":"7. Problems to Solve","text":"<ol> <li> <p>Prove that if \\(n\\) is an integer satisfying \\(n^{4}+4 n^{3}+3 n^{2}+n+4000=0\\), then \\(n\\) must be even.</p> </li> <li> <p>In one of the examples in this chapter, we showed that if \\(x\\) is a real solution to \\(x^{5}+3 x^{2}+7 x+2=0\\), then \\(x\\) must be negative. Why can't we say that \\(x\\) is a solution to this equation if and only if \\(x\\) is negative?</p> </li> <li> <p>Show that for all integers \\(n\\) greater than \\(2,1+2+3+\\cdots+n\\) is a composite number.</p> </li> <li> <p>Given 11 points, no four of which are coplanar, each triangle formed by three of the points is given a letter \\(A, B, C\\), or \\(D\\). At most how many triangles must get the same letter? (Mandelbrot #1)</p> </li> <li> <p>Show that if \\(x / y\\) and \\(y / x\\) are both integers, then \\(|x|=|y|\\).</p> </li> <li> <p>Explain the proposed paradox in the following story. Three men rent a hotel room. They are charged 15 dollars each. Later, the manager decides they should only have been charged 40 dollars for the room, so he gives 5 dollars to a messenger to give to the men. The messenger dishonestly keeps two dollars and gives each man 1 dollar. Each man has paid 14 dollars for the room and the messenger has 2 dollars, for a total of 44 dollars; however, the men originally paid 45 dollars for the room. Where's the other dollar?</p> </li> <li> <p>Prove that if \\(|x|+x&gt;0\\), then \\(x\\) must be positive.</p> </li> <li> <p>Chairs are equally spaced around a table and numbered from 1 to \\(2 n\\). Prove that if every odd chair is directly opposite another odd numbered chair, then the number of chairs is a multiple of 4 .</p> </li> <li> <p>Prove that between any two consecutive multiples of 7 , exclusive, there are exactly two multiples of three.</p> </li> <li> <p>Given three lines through the origin, prove that there must be a pair of them which form an angle of less than or equal to \\(60^{\\circ}\\).</p> </li> <li> <p>Show that $$ \\frac{1}{1 \\cdot 2}+\\frac{1}{2 \\cdot 3}+\\cdots+\\frac{1}{n \\cdot(n+1)}=\\frac{n}{n+1} $$</p> </li> <li> <p>Prove that a number has an odd number of distinct factors if and only if the number is a perfect square.</p> </li> <li> <p>Three women are in a round-robin tennis tournament in which they each play each other player once. Prove that at least one player must lose one game and win one game.</p> </li> <li> <p>Show that \\((1+2+3+\\cdots+n)^{2}=1^{3}+2^{3}+3^{3}+\\cdots+n^{3}\\).</p> </li> <li> <p>A drawer contains 8 grey socks, 5 white socks, and 10 black socks. If socks are randomly taken from the drawer without replacement, how many must be taken to be sure that 4 socks of the same color have been taken? (MATHCOUNTS 1988)</p> </li> <li> <p>A woman has written \\(k\\) letters and addressed \\(k\\) envelopes for them. She then randomly puts the letters in the envelopes. Show that the number of letters which are put in the proper envelope can be any number from 0 to \\(k\\) except \\(k-1\\).</p> </li> <li> <p>Prove that \\(n^{5}-n\\) is divisible by 10 for all integers \\(n\\).</p> </li> <li> <p>Each of 6 points in space is connected to the other 5 points by line segments. Each segment thus formed is colored green or purple. Show that it is impossible to color all the segments without forming a triangle in which all three segments are the same color.</p> </li> </ol> <p>the BIG PICTURE</p> <p>To mathematicians, a proof is more than just a confirmation of the truth of an already wellunderstood principle; it shows a true understanding of the principle, and conveys an aesthetic value.</p> <p>For this reason, people interested in math delight in coming up with proof after proof of a result. Each new proof shows a different facet of the theorem, a geometric or algebraic or topological or analytic or differential facet. For example, Karl Friedrich Gauss, one of the greatest mathematicians ever, had around six different proofs for the Fundamental Theorem of Algebra and multiple proofs of other important theorems. Throughout history, proofs of the Pythagorean Theorem, proofs that the area of a circle is indeed \\(\\pi r^{2}\\), and proofs of the Angle Bisector Theorem have all enriched their subjects.</p> <p>People have always sought to find the simplest, most elegant way to prove a theorem. The Mathematical Association of America's Mathematics Magazine even has a section devoted to this principle, in which a proof must consist only of a revealing diagram and a few equations. The most beautiful proof I know of the Pythagorean Theorem, discovered by an ancient Hindu mathematician, consisted only of the diagram and one word: BEHOLD! Developing proofs of this type is an excellent exercise, but don't overdo it, or your proofs will soon be unreadable.</p>"},{"location":"math/proof-writing/#resources","title":"Resources","text":""},{"location":"math/proof-writing/#videos","title":"Videos","text":"<ul> <li> <p>Introduction to Proof Writing -- Full Course!!!  (en)</p> </li> <li> <p>Intro To Math Proofs (Full Course) (en)</p> </li> <li> <p>Proofs by AMO (ar)</p> </li> <li> <p>Principles of Logic and Patterns of Proof (ar)</p> </li> </ul>"},{"location":"math/proof-writing/#pdfs","title":"PDFs","text":"<ul> <li> <p>Book of Proof (en)</p> </li> <li> <p>Writing up solutions Ed Barbeau (en) (french)</p> </li> <li> <p>Advice for writing proofs Evan Chen (en)</p> </li> </ul>"},{"location":"math/proof-writing/#bonus","title":"Bonus","text":"<ul> <li>Math's Fundamental Flaw  (en)</li> </ul>"}]}